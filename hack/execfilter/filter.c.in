// The core filter implementation for execfilter.
// Written by Lenik, Nov 2013.

#include <sys/types.h>
#include <sys/stat.h>
#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "filter.h"
#include "trie.h"
#include "path.h"
#include "qstr.h"

#define CONFIGDIR "@configdir@"

#define E_FILT 127

#undef DLSYM_MAX
#define DLSYM_MAX 128

typedef struct _symres_t {
    char name[PATH_MAX];
    char fn[DLSYM_MAX];
    void *handle;
    void *proc;
} symres_t;

symres_t gate_sr;                       /* the global gate */
GHashTable *formats;                    /* extension -> symres_t */

#undef LINE_MAX
#define LINE_MAX 4095

GHashTable *pmap;
int pmap_ver;                           /* file version. used in 2.0+ */
program_conf_t *pconf;
program_conf_t *preset;                 /* predefiend config. used in 2.0+ */

static const char *parse_file(const char *path);
static const char *parse_confs(char *script, const char *location);

void pmap_load() {
    DIR *configdir;
    struct dirent *ent;
    char name[PATH_MAX + 1];
    int dirlen;
    const char *errmsg;

    pmap = g_hash_table_new(g_str_hash, g_str_equal);
    formats = g_hash_table_new(g_str_hash, g_str_equal);

    strcpy(name, CONFIGDIR);
    configdir = opendir(name);

    if (configdir) {
        strcat(name, "/");
        dirlen = strlen(name);

        while ((ent = readdir(configdir)) != NULL) {

            /* skip hidden files. */
            if (ent->d_name[0] == '.')
                continue;

            switch (ent->d_type) {
            case DT_LNK:
            case DT_REG:
                strcpy(name + dirlen, ent->d_name);
                errmsg = parse_file(name);
                if (errmsg != NULL) {
                    fprintf(stderr, "execfilter fatal error: %s\n", errmsg);
                    exit(E_FILT);
                }
            }
        }
    }
}

static char *readtok(char **headp) {
    static char kwbuf[512];
    char *head = *headp;
    char *end;
    int len;

    /* trim left. */
    while (isspace(*head)) head++;

    end = head;
    while (*end && !isspace(*end))
        end++;

    len = end - head;
    strncpy(kwbuf, head, len);
    kwbuf[len] = '\0';

    /* trim left for the remaing text. */
    while (isspace(*end)) end++;
    *headp = end;

    return kwbuf;
}

/* String tokenizer, by replacing the end-of-line character by NUL.
   Return the head, or NULL if EOT it met. */
static char *strtok_eol(char *head, char **endp) {
    char *end = head;
    char ch;
    if (*end == '\0')
        return NULL;

    while ((ch = *end)) {
        if (ch == '\n') {
            //if (end > head && end[-1] == '\r')
            //    end[-1] = '\0';         /* Replace CR.LF by NUL.NUL. */
            *end++ = '\0';
            break;
        }
        end++;
    }

    if (endp)
        *endp = end;
    return head;
}

static const char *parse_file(const char *path) {
    struct stat sb;
    if (stat(path, &sb) == -1) {
        fprintf(stderr, "Error: Failed to get file stat: %s\n", path);
        perror("");
        return "stat";
    }

    size_t size = sb.st_size;
    char *data = malloc(size + 1);
    if (data == NULL) {
        fprintf(stderr, "Insufficient memory to read config file %s.", path);
        return "memory out";
    }

    FILE *f = fopen(path, "rt");
    if (f == NULL) {
        fprintf(stderr, "Failed to open file %s: ", path);
        perror("");
        return "open config";
    }

    int cb = fread(data, 1, size, f);
    if (cb != size)
        return "read incomplete";

    data[cb] = '\0';
    fclose(f);

    const char *errmsg = parse_confs(data, path);

    free(data);

    return errmsg;
}

static const char *parse_confs(char *script, const char *location) {
    char *head = script;
    char *p;
    char *token;
    program_conf_t *conf = NULL;
    GHashTable *tab;
    xmode_t mode;

    while ((p = strtok_eol(head, &head))) {
        token = readtok(&p);

        /* trim right. */
        char *end = p + strlen(p);
        while (end > p && isspace(end[-1]))
            *--end = '\0';

        switch (*token) {
        case '\0':
            continue;                   /* empty line */
        case '#':
            continue;                   /* comment line */

        case 'a':
            if (strcmp("allow", token) == 0) {
                if (conf == NULL) {
                    fprintf(stderr, "Error: program (for-clause) hasn't been specified yet.\n");
                    continue;
                }

                char *which = path_find(p);
                if (which != NULL)
                    p = which;

                mode = get_execution_mode(conf, p);
                mode |= F_ALLOW;
                mode &= ~F_DENY;
                set_execution_mode(conf, p, mode);
                break;
            }

        case 'd':
            if (strcmp("default", token) == 0) {
                if (conf == NULL) {
                    fprintf(stderr, "Error: program (for-clause) hasn't been specified yet.\n");
                    continue;
                }

                if (strcmp("allow", p) == 0)
                    conf->mode_all |= F_ALLOW;
                if (strcmp("deny", p) == 0)
                    conf->mode_all |= F_DENY;
                break;
            }

            if (strcmp("deny", token) == 0) {
                if (conf == NULL) {
                    fprintf(stderr, "Error: program (for-clause) hasn't been specified yet.\n");
                    continue;
                }

                char *which = path_find(p);
                if (which != NULL)
                    p = which;

                mode = get_execution_mode(conf, p);
                mode &= ~F_ALLOW;
                mode |= F_DENY;
                set_execution_mode(conf, p, mode);
                break;
            }

        case 'f':
            /* for PATH */
            if (strcmp(token, "for") == 0) {
                conf = g_hash_table_lookup(pmap, p);
                if (conf == NULL) {
                    conf = (program_conf_t *) malloc(sizeof(program_conf_t));
                    tab = g_hash_table_new(g_str_hash, g_str_equal);
                    conf->modes = tab;
                    conf->mode_all = 0;
                    conf->mask = -1;
                    g_hash_table_insert(pmap, strdup(p), conf);
                }
                tab = conf->modes;
                break;
            }

            /* format EXTNAME LIBNAME FN=decode */
            if (strcmp("format", token) == 0) {
                char *ext = readtok(&p);
                if (ext == NULL) {
                    fprintf(stderr, "Error: extension name isn't specified.\n");
                    continue;
                }

                char *libname = readtok(&p);
                if (libname == NULL) {
                    fprintf(stderr, "Error: library name isn't specified. (format: %s)\n", ext);
                    continue;
                }

                char *fn = readtok(&p);
                if (fn == NULL)
                    fn = "decode";

                symres_t *sr = g_hash_table_lookup(formats, ext);
                if (sr != NULL) {
                    fprintf(stderr, "Error: format %s is already defined.\n", ext);
                    continue;
                }

                sr = (symres_t *) malloc(sizeof(symres_t));
                memset(sr, 0, sizeof(symres_t));
                g_hash_table_insert(formats, strdup(ext), sr);

                sr->handle = dlopen(libname, RTLD_LAZY);
                if (sr->handle == NULL) {
                    fprintf(stderr, "Failed to open library %s", libname);
                    perror("");
                    return "load fmt lib";
                }

                sr->proc = dlsym(sr->handle, fn);
                if (sr->proc == NULL) {
                    fprintf(stderr, "No such function in library %s: %s.\n", libname, fn);
                    return "resolve fmt fn";
                }

                strcpy(sr->name, libname);
                strcpy(sr->fn, fn);
                break;
            }

        case 'g':
            /* gate LIBNAME FN=gate */
            if (strcmp("gate", token) == 0) {
                char *libname = readtok(&p);
                if (libname == NULL) {
                    fprintf(stderr, "Error: library name isn't specified. (gate)\n");
                    continue;
                }

                char *fn = readtok(&p);
                if (fn == NULL)
                    fn = "gate";

                if (gate_sr.handle) {
                    dlclose(gate_sr.handle);
                    memset(&gate_sr, 0, sizeof(gate_sr));
                }

                gate_sr.handle = dlopen(libname, RTLD_LAZY);
                if (gate_sr.handle == NULL) {
                    fprintf(stderr, "Failed to open library %s", libname);
                    perror("");
                    return "load gate lib";
                }

                gate_sr.proc = dlsym(gate_sr.handle, fn);
                if (gate_sr.proc == NULL) {
                    fprintf(stderr, "No such function in library %s: %s.\n", libname, fn);
                    return "resolve gate fn";
                }

                strcpy(gate_sr.name, libname);
                strcpy(gate_sr.fn, fn);
                break;
            }

        default:
            fprintf(stderr, "Error: illegal syntax in %s: %s %s.\n",
                    location, token, p);
            /* Dont exit program, otherwise the system will be unusable. */
        } /* switch (token) */
    } /* while: strtok_eol */
    return NULL;
}

static int initialized;
static void lazy_init() {
    if (initialized)
        return;

    pmap_load();

    /* normalize the current process and grab the entry. */
    char path[PATH_MAX + 1];
    int cc;
    if ((cc = readlink("/proc/self/exe", path, PATH_MAX)) == -1) {
        perror("readlink");
        exit(1);
    }
    path[cc] = '\0';

    /* conf maybe undefined, if the program is not configured.  */
    pconf = g_hash_table_lookup(pmap, path);

    if (pconf == NULL) {
        pconf = (program_conf_t *) malloc(sizeof(program_conf_t));
        pconf->modes = g_hash_table_new(g_str_hash, g_str_equal);
#ifdef DEBUG
        printf("Warning: %s isn't configured, yet.\n", path);
#endif
    }

    initialized = 1;
}

static void pmap_each_mode(gpointer key, gpointer value, gpointer data) {
    const char *target = (const char *) key;
    printf("    ");

    xmode_t mode = (xmode_t) value;
    if (mode & F_ALLOW)
        printf("allow ");
    if (mode & F_DENY)
        printf("deny ");

    printf("%s", target);
    printf("\n");
}

static void pmap_each_tab(gpointer key, gpointer value, gpointer data) {
    const char *program = (const char *) key;
    program_conf_t *conf = (program_conf_t *) value;

    xmode_t m0 = conf->mode_all & conf->mask;

    printf("for %s\n", program);
    switch (m0 & (F_ALLOW | F_DENY)) {
    case F_ALLOW:
        printf("    order allow, deny\n");
        break;
    case F_DENY:
        printf("    order deny, allow\n");
        break;
    case F_ALLOW | F_DENY:
        printf("    order none\n");
        break;
    }

    g_hash_table_foreach(conf->modes, pmap_each_mode, 0);
    printf("\n");
}

void pmap_dump() {
    lazy_init();
    g_hash_table_foreach(pmap, pmap_each_tab, 0);
}

xmode_t get_execution_mode(program_conf_t *conf, const char *norm_path) {
    if (conf == NULL) {
        lazy_init();
        conf = pconf;
        assert(conf != NULL);
    }

    gpointer value = g_hash_table_lookup(conf->modes, norm_path);
    xmode_t mode = (xmode_t) value;
    mode |= conf->mode_all;
    mode &= conf->mask;
    return mode;
}

void set_execution_mode(program_conf_t *conf, const char *norm_path, xmode_t mode) {
    if (conf == NULL) {
        lazy_init();
        conf = pconf;
        assert(conf != NULL);
    }

    gpointer value = (gpointer) mode;
    g_hash_table_insert(conf->modes, strdup(norm_path), value);
}

static pid_t stat_ppid(pid_t pid) {
    char path[PATH_MAX];
    FILE *f;
    char comm[PATH_MAX];
    char state;
    pid_t ppid;

    sprintf(path, "/proc/%d/stat", pid);
    if ((f = fopen(path, "rt")) == NULL)
        return -1;

    fscanf(f, "%d %s %c %d", &pid, comm, &state, &ppid);
    fclose(f);

    return ppid;
}

xmode_t get_execution_mode_rec(pid_t pid, const char *obj) {
    xmode_t all = 0;
    char *obj_norm = path_find_norm(obj);

    lazy_init();

    while (pid != 0 && pid != -1) {
        char psym[PATH_MAX];
        char bin[PATH_MAX];
        int cc;
        program_conf_t *conf;

        sprintf(psym, "/proc/%d/exe", pid);
        cc = readlink(psym, bin, PATH_MAX);

        if (cc == -1) {
            if (errno == EACCES) {
                /* skip this one. */
            } else {
                perror("readlink");
                exit(E_FILT);
            }
        } else {
            bin[cc] = '\0';
            conf = g_hash_table_lookup(pmap, bin);
            if (conf) {
                xmode_t m = get_execution_mode(conf, obj_norm);
                // printf("execution mode for [%d] %s: %d\n", pid, bin, c);
                all |= m;
            }
        }

        pid = stat_ppid(pid);
    }

    return all;
}
