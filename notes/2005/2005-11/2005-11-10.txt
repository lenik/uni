BODZ | S-FIA & TC
Dir-T|Note                                                  http://tc.bodz.net
Snima Denik Personal                                            denik@bodz.net

NOTES FOR SPEED                                 STATUS Draft   SERIAL NFS00153

   TITLE  ____________________________________________________________________
KEYWORDS  ____________________________________________________________________


> QQ 图标闪得太快怎么办？

自从建了个 QQ 群 (10876003)，每天收到一大堆消息。
看消息和回消息并不是很麻烦，但是这个图标不停的闪烁搞得人有点心烦意乱。
如果禁止闪烁，即"收到消息时不提示" 这样就不知道什么时候有消息了，那这个群还有什么用，不如去泡论坛了。
所以，关键是图标闪得太快了，要让它慢下来才行。
慢到什么程度呢？很慢很慢。。对了，慢到不闪烁为止。
为了实现这个变动，我开始了为期1天的 QQ 破解之旅。

版本 QQ 2005 正式版 (V05.0.200.082)。

首先，当然是从 Shell32.dll 开始，因为任务栏图标都通过这个库操纵。
图标不像窗体有 FlashWindow 这样的函数，因此只有两个可能：

1，NIM_ADD/NIM_DELETE 来回切换。
2，NIM_ADD 建立图标之后通过 NIM_MODIFY 切换 HICON。

从运行看 2 的可能性比较大，所以就找 Shell_NotifyIcon 的 NIM_MODIFY 调用，IDA 逆向了再说 (ND 是个大胖子)。
查 shell.h 得知 NIM_MODIFY == 1，找到入口：
    4a881e  变量 message
    4b309c  NIM_MODIFY

loc_4A881E: (app_notifyicon)
                cmp     dword ptr [ecx+118h], 0
                jz      short loc_4A8835
                push    [esp+lpData]    ; lpData
                push    [esp+4+dwMessage] ; dwMessage
                call    ds:Shell_NotifyIconA

loc_4B3091:                             ; CODE XREF: manage_tray_icon+18Cj
                mov     [eax], ecx
                lea     eax, [esi+424h]
                push    eax             ; lpData
                push    1               ; dwMessage NIM_MODIFY
                call    ds:Shell_NotifyIcon

对于 4a881e 很明显是个壳，只是多了一层屏蔽选项，先判断任务栏图标是不是被禁用了，仅当启用时才执行。
因此所有该调用也要追踪，继续找 NIM_MODIFY，又得到如下入口：
    4a823b  NIM_MODIFY
    4a853a  NIM_MODIFY
    4a8746  NIM_MODIFY
    4a887b  NIM_MODIFY
    4a88cc  NIM_MODIFY

4a823b:
                lea     eax, [esi+4Ch]
                push    eax
                push    1               ; NIM_MODIFY
                jmp     short loc_4A8256

new:                                    ; CODE XREF: tray_set?+Dj
                mov     eax, [esp+arg_4]
                mov     [esi+0F4h], eax
                mov     [esi+60h], eax
                lea     eax, [esi+4Ch]
                push    eax             ; lpData
                push    0               ; NIM_ADD

loc_4A8256:                             ; CODE XREF: tray_set?+29j
                mov     ecx, esi
                call    app_notifyicon

4a853a:
                lea     eax, [esi+4Ch]
                push    eax             ; lpData
                push    1               ; dwMessage
                call    app_notifyicon

4a8746:
                lea     eax, [esi+4Ch]
                mov     ecx, esi
                push    eax             ; lpData
                push    1               ; dwMessage
                call    app_notifyicon

4a887b:
                push    ebx             ; lpData
                push    1               ; dwMessage NIM_MODIFY
                mov     ecx, ebp
                mov     [esi+0ECh], edx ; +EC  remainder
                mov     eax, [esi+0F4h] ; DWORD *table
                mov     eax, [eax+edx*4] ; table[remainder]
                mov     [esi+40h], eax  ; +40  Table Entry
                call    app_notifyicon

4a88cc:
                push    ebx             ; lpData
                inc     eax
                push    1               ; dwMessage NIM_MODIFY
                cdq
                idiv    ecx
                mov     ecx, ebp
                mov     [esi+0ECh], edx
                mov     eax, [esi+0F4h]
                mov     eax, [eax+edx*4]
                mov     [esi+40h], eax
                call    app_notifyicon

这些入口看起来都差不多，因为大量使用了类，this 指针的相对偏移使代码看起来很吃力。既然是闪烁，很容易联想到定时器，那么是不是 Shell_NotifyIcon 应该和 SetTimer 有牵连呢？

于是分析 SetTimer 的使用情况，结果发现大多数定时器都在 1 秒间隔以上，其中有两个定时器比较快，一个是
4b2fa5:
                push    ebx             ; lpTimerFunc
                push    26Ah            ; uElapse 618ms
                push    1               ; nIDEvent
                push    dword ptr [esi+20h] ; hWnd
                call    ds:SetTimer
另一个是
4b3328:
                push    0               ; lpTimerFunc
                push    12Ch            ; uElapse 300ms
                push    2               ; nIDEvent
                push    dword ptr [ecx+20h] ; hWnd
                mov     dword ptr [ecx+44h], 1
                mov     [ecx+48h], edx
                mov     [ecx+4Ch], eax
                call    ds:SetTimer

这两个定时器分别是 618毫秒和 300毫秒，结果我用手表就验证了这两个时间是错误的，间隔时间应该在 370-430 毫秒之间。

那么这么多 NIM_MODIFY 究竟是哪个呢？
来个动态跟踪吧！

用 Ollydbg 把这些 Shell_NotifyIcon 全部设置断点，凶手立刻被抓到了，就是 4a881e 那个。

看到 WaitForSingleObject 的 Timeout 都是 0，这是一个值得注意的地方。
为什么呢？因为一个循环如果没有等待，或者是不给其它线程调度的机会，那么这个循环就会耗尽CPU资源，更重要的是，WaitForSingleObject 是一种同步技术，对于抢占式操作系统（Windows）这样的循环会引起死锁，使系统失去响应。
因此，这里一定有某个等待。既然不在 WaitForSingleObject，分析一下程序前后，只有一个可能，就是这个调用：

4a8897:
                push    dword ptr [esi+108h] ; interval?
                mov     ecx, esi
                call    ds:?QueryExitEvent@CThreadModel@@IAEHK@Z
                        ; ^^^^ 注意这里
                test    eax, eax
                jnz     short exit_2    ; Exit requested.

                        ; 事件 X
                mov     edi, ds:WaitForSingleObject
                push    eax             ; dwMilliseconds = 0, Immediately
                push    dword ptr [esi+100h] ; event-X
                call    edi ; WaitForSingleObject
                test    eax, eax        ; 0 == WAIT_OBJECT_0 (signaled)
                                        ; 102h == WAIT_TIMEOUT
                                        ; 80h == WAIT_ABANDONED
                jnz     short after_nodify ; unsignaled?

switch?:
                mov     ecx, [esi+0F0h]
                test    ecx, ecx
                jle     short exit_fail
                mov     eax, [esi+0ECh]
                push    ebx             ; lpData
                inc     eax
                push    1               ; dwMessage NIM_MODIFY
                cdq
                idiv    ecx
                mov     ecx, ebp
                mov     [esi+0ECh], edx
                mov     eax, [esi+0F4h]
                mov     eax, [eax+edx*4]
                mov     [esi+40h], eax
                call    app_notifyicon  ; T-PASS-1

after_nodify:                           ; CODE XREF: blink_thread_proc?+63j
                push    0               ; dwMilliseconds, Immediately
                push    dword ptr [esi+100h] ; hHandle

                        ; 事件 Y
                call    edi ; WaitForSingleObject
                test    eax, eax
                jz      short blink_loop?? ; been signaled?
                lea     edi, [esi+104h] ; event-Y?
                push    0               ; dwMilliseconds
                push    dword ptr [edi] ; hHandle
                call    ds:WaitForSingleObject
                test    eax, eax
                jz      short blink_loop?? ; interval?
                push    dword ptr [edi] ; hEvent
                call    ds:SetEvent     ; signal the event-Y
                jmp     blink_loop??    ; interval?


这个调用究竟做了什么，看来有必要研究一下 "MFC" 的 CThreadModel 类。
找找找。。CThreadModel? MFC 没这个类？ND，这个是腾讯的，在 QQBaseClassInDll.dll 中 （又是一个胖子！汗~）

用 IDA 逆向，浏览了一下 CThreadModel实现不是很复杂，大致看一下主要做了以下事情：
    61242c16: QueryExitEvent(timeout) 如果 eventQuit 触发则返回1

以及 CThreadModel 的内存布局
    +8  eventQuit
    +10 eventX
    +14 eventY

因此等待是在查询退出状态时实现的，再看看前面的代码，等待时间应该在某个对象属性中。（动态跟踪时可以看到等待时间是400ms，190h）
不过，这里可以发现一个BUG，就是说，当收到消息并在任务栏闪烁图标时，QQ必须要等到图标在显示和不显示的切换瞬间才能执行其它命令，就是说，如果闪烁间隔1小时的话，在最糟糕的情况下QQ的响应时间要延迟半个小时。

在虚表 4e7bd0 跟踪实例，看到虚表的两个用途：
    4a7e4b  初始化
            object->[20] -> blink-proc
    4a7f27  析构

忽略析构，查初始化的用途，可以断定 488cca 用于初始化任务栏图标的相关资源：
488cf4:
                call    sub_4a7dea
                mov     ebx, eax
                jmp     short loc_488CFF

在 4a7dea 中看到实例的初始化过程：
                call    ds:CreateEventA
                push    eax
                mov     ecx, ebx
                mov     [esi+120h], eax     ; <-- 事件 X ?
                call    ds:?AddEvent@CThreadModel@@IAEXPAX@Z ; CThreadModel::AddEvent(void *)
                push    edi             ; lpName
                push    1               ; bInitialState
                push    1               ; bManualReset
                push    edi             ; lpEventAttributes
                call    ds:CreateEventA
                push    eax
                mov     ecx, ebx
                mov     [esi+124h], eax     ; <-- 事件 Y ?
                call    ds:?AddEvent@CThreadModel@@IAEXPAX@Z ; CThreadModel::AddEvent(void *)
                mov     ecx, [ebp-0Ch]
                or      dword ptr [ebp-4], 0FFFFFFFFh
4a7ed7:
                mov     dword ptr [esi+128h], 190h

有没有注意到，这里创建的两个事件 +120 +124 和前面的事件等待 +100 +104 刚好差了 20H 个便移，而前面线程状态查询所使用的实例成员是 +108，果然 +128 所初始化的 190H 就是等待时间 400ms 了，不过高兴得早了点，修改了 QQ.exe (偏移 0A7EDD) 后图标闪烁速度仍就很快，ND 再把Ollydbg 呼出来，这回不用静态了，因为后面都是类调用，静态分析毫无头绪，拿 ESI+128 那个地址设写入断点，找到两个入口，竟然是在 QQHelper.dll 里面 （又是个胖子，汗~）：

; StartLoginTaskTrayAnimation +199
61469d42:
                lea     ecx, [ebp-24h]
                call    sub_6146A6C1
                mov     eax, [ebp-24h]
                push    12Ch            ; INTERVAL!
                push    dword ptr [ebp-1Ch]
                mov     ecx, [eax]
                push    dword ptr [ebp-10h]
                push    eax
                call    dword ptr [ecx+18h]

; StartTrayAnimate +0D75
614586e0:
                push    190h
                push    edx
                mov     ecx, [eax]
                push    2
                push    eax
                call    dword ptr [ecx+18h]

其中一个 12Ch （300毫秒）是控制 QQ 登陆时的任务栏图标动画，另一个 190h （400ms）就是一般图标闪烁的间隔。用 UltraEdit 打开 QQHelper.dll 编辑，按 Ctrl-G 输入 0x0186e1，是不是 90 01 00 00？把它改成 00 00 01 00，大功告成，ND QQ 的图标终于可以停止闪烁了 ;-)
