#!/bin/bash

stage=0
cont=

if [ "${1:0:1}" = : ]; then
    stage=${1#:}
    shift
fi

if [ "${1:0:1}" = '~' ]; then
	cont="${1:1}"
	shift
fi

if [ -z "$1" ]; then
    echo svn-dump [:STAGE] [~continue-file] REPO-DIR
    exit 1
fi

# dump each packages to .dump/YYYYMMDD.PACKAGE.REV
if [ $stage -le 1 ]; then
  echo 1. Dump

    rm -fR .dump; mkdir -p .dump

    for d in "$@"; do
        ROOT=`readlink -f $d`
        echo "    $ROOT"
        pkg=`basename $d`

        while IFS='|' read rev author date; do
            rev="${rev#r}"
            rev="${rev% }"
            date="${date%+*}"
            date=${date//[^0-9]}
            fn=".dump/$date.$pkg.$rev"
            if ! msg=`svnadmin dump -r $rev --incremental $ROOT 2>&1 >$fn`; then
                echo "Error at package $pkg, rev $rev, date $date: "
                echo "    $msg"
                exit 1
            fi
            if [ ! -f "$fn" ]; then
		echo "dump not created: \"$fn\""
		echo "last message: $msg"
		exit 1
            fi
            echo -n .
        done < <(svn log file://$ROOT -q | grep '^r')
        echo
    done
fi

# touch/set the date on the dump file, and move to .reindex/REORDER-ID.PACKAGE
if [ $stage -le 2 ]; then
  echo 2. Reindex
    rm -fR .reindex; mkdir -p .reindex
    cd .dump
    i=1
    for f in *; do
        id=00000000$i
        id=${id: -8}
        dstr="${f:0:4}-${f:4:2}-${f:6:2} ${f:8:2}:${f:10:2}:${f:12:2}"
        touch -d"$dstr" $f
        cp $f ../.reindex/$id.${f#*.}
        ((i++))
        echo -n .
    done
    echo
    cd ..
    #rmdir .dump
fi

# fix revision if any... (not used)
if [ $stage -le 3 ]; then
  echo 3. Reindex - fix revision
    cd .reindex
    for f in *; do
        f_join=${f%%.*}
        f_pack=${f#*.}
        f_orig=${f_pack#*.}
        f_pack=${f_pack%.*}

        pack_maxvar=_packmax_$f_pack
        pack_max=${!pack_maxvar}
        if [ -z "$pack_max" ]; then pack_max=0; fi
        if [ "$f_orig" -lt "$pack_max" ]; then
            match_orig=
            for ((i = f_orig + 1; i <= pack_max; i++)); do
		for match in *.$f_pack.$i; do
			if [ ! -f $match ]; then continue; fi
                    match_join=${match%%.*}
                    # match_orig=${match##*.}
                    match_orig=$i
                    mv $f $match_join.$f_pack.$f_orig
			break 2
                done
            done
            if [ -z "$match_orig" ]; then
		echo "Can't find a insert point to move back a post-fix rev"
		exit 1
            fi
            echo -n "<$f_pack.$f_orig -> $match_orig>"
        else
		eval "$pack_maxvar=$f_orig"
		echo -n .
        fi
    done
    echo
    cd ..
fi

# prepare for merge, create empty dir-struct
if [ $stage -le 4 ]; then
  echo 4. Create merge repository

    # echo "  Init merged modules structure"
    rm -fR .merged
    svnadmin create .merged
    ROOT=`readlink -f .merged`
    initdirs=
    for d in "$@"; do
        initdirs="$initdirs file://$ROOT/$d"
    done
    svn mkdir -m "[Merge SVN Repositories] Create parent dirs" $initdirs >/dev/null
fi

if [ $stage -le 5 ]; then
  echo 5. Load
    for f in .reindex/*; do
        if [ -n "$cont" -a "$f" \< "$cont" ]; then continue; fi
        s=${f##*/}
        newrev=${s%%.*}
        newrev=$((1$newrev-100000000+1))
        s=${s#*.}
        module=${s%.*}
        oldrev=${s#*.}
        if svnadmin load --parent-dir $module .merged <$f >/dev/null; then
            echo -n .
        else
            echo Error loading $f
            echo "Command: svnadmin load --parent-dir $module .merged <$f"
            exit 1
        fi
        # After reindex-fix, the joined revision is no more correct.
        #read current <.merged/db/current
        #if [ $newrev != $current ]; then
        #    echo "$f: Expect revision $newrev, but current is $current"
        #    #exit 2
        #fi
    done
    echo
fi
