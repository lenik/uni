#!/usr/bin/env perl

use strict;
use warnings;

sub add_subst($$);
sub load_substs($$);
sub build_re($$);

our %subst;
our %subst_re;
our %index;
our %index_re;

sub add_subst($$) {
    my $key = shift;
    my $val = shift;
    $subst{$key} = $val;
    #$index{$val} = [] unless defined($index{$val});
    #my $rkeys = $index{$val};
    #push(@{$rkeys}, $key);
}

sub load_substs($$) {
    my $prefix = shift;
    my $dir = shift;

    for my $f (<$dir/*>) {
        my ($dirname, $basename) = $f =~ m{^(.*?)([^/]+)$};
        my $fqn = ($prefix eq '') ? $basename : "$prefix:$basename";

        if (-d $f) {
            load_substs($fqn, $f);
        } elsif (-f $f) {
            open(IN, "<$f") or die "Can't open $f: ";
            my $line = 0;
            while (<IN>) {
                s/^\s+//;
                next if $_ eq '';
                next if /^#/;
                $line++;
                my ($key, $val) = /^(.*?)\s*=\s*(.*)$/;
                $key = $fqn.'['.$key.']';
                add_subst($fqn, $val) if $line == 1;
                add_subst($key, $val);
            }
            close IN;
        }
    }
}

sub build_re($$) {
    my $map = shift;
    my $map_re = shift;
    for my $k (keys %{$map}) {
        my $re = $k;
        $re =~ s/([\\\[\]\/\"\'.?*+\(\)^\$])/\\$1/g;
        if ($k =~ /\]$/) {
            $map_re->{$k} = qr/\b$re/;
        } else {
            $map_re->{$k} = qr/\b$re\b(?!\[)/;
        }
    }
}

load_substs('', "/etc/coolcmd/subst");
load_substs('', "~/.coolcmd/subst");

build_re(\%subst, \%subst_re);
#build_re(\%index, \%index_re);

#use Data::Dumper;
#print Dumper(\%subst);
#print Dumper(\%subst_re);

while (<>) {
    for my $key (keys %subst) {
        my $val = $subst{$key};
        my $re = $subst_re{$key};
        s/$re/$val/g;
    }
    print;
}
