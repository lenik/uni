#!/usr/bin/perl

=head1 NAME

catme - Stupid Text Concatenater

=cut
use strict;
use vars qw($LOGNAME $LOGLEVEL);
use cmt::log(3);
    $LOGNAME    = 'catme'; # $0 =~ /([^\/\\.]+)(?:\.\w+)*$/;
use cmt::path('path_split');
use cmt::util('readfile');
use cmt::vcs('parse_id');
    my %RCSID   = parse_id('$Id: - @VERSION@ @DATE@ @TIME@ - $');
use FileHandle;
use Getopt::Long;
    Getopt::Long::Configure('gnu_getopt');

sub _main; sub _version; sub _help;

my $pkgdatadir = '@pkgdatadir@';
    $pkgdatadir = '/usr/share/catme' unless -d $pkgdatadir;

my $opt_configdir = $ENV{HOME} . "/.config/catme";
my @opt_searchpath = ('.');
my $opt_delim;
my $opt_keep = 0;

my @dirstack = ();
my @searchpath;
my ($del, $der);
my ($ndel, $nder);
my @extstack;

my $cmds = {
    'dnl' => \&fn_dnl,
    'comment' => \&fn_dnl,
    'import' => \&fn_import,
    'include' => \&fn_include,
    'mixin' => \&fn_mixin,
    'sinclude' => \&fn_sinclude,
};

my $langtab = {
    'p' => 'perl',
    'pl' => 'perl',
    'py' => 'python',
    'r' => 'ruby',
    'sql' => 'sql',
    'ddl' => 'sql',
};

my $lang_delim = {
        'sql' => [ '--', '' ],
    };

sub _boot {
    GetOptions('q|quiet'        => sub { $LOGLEVEL-- },
               'v|verbose'      => sub { $LOGLEVEL++ },
               'version'        => sub { _version; exit 0 },
               'h|help'         => sub { _help; exit 0 },
               'L|lib=s'        => \@opt_searchpath,
               'c'              => sub { $opt_delim = [ '/*', '*/' ] },
               'u|unix'         => sub { $opt_delim = [ '#', '' ] },
               'd|dash-dash'    => sub { $opt_delim = [ '--', '' ] },
               'k|keep'         => \$opt_keep,
               )
        or exit(1);

    my $lib = $ENV{'LIB'};
    if (defined $lib) {
        for my $item (split(/:/, $lib)) {
            next if $item eq '';
            push @opt_searchpath, $item;
        }
    }
    
    for my $path (@opt_searchpath) {
        _log2 "Search: $path";
    }

    _main;
}

=head1 SYNOPSIS

B<catme>
    S<[ B<-q> | B<--quiet> ]>
    S<[ B<-v> | B<--verbose> ]>
    S<[ B<-h> | B<--help> ]>
    S<[ B<--version> ]>
    S<[ B<--> ]>
    S<[ I<...the rest of arguments...> ]>

=head1 DESCRIPTION

B<catme> is a WHAT used for WHAT. It HOW-WORKS.

BACKGROUND-PROBLEM.

HOW-catme-RESOLVES.

=head1 OPTIONS

=over 8

=item B<-m> | B<--my-option>

...

=item B<-q> | B<--quiet>

Repeat this option to suppress unimportant information to display.

=item B<-v> | B<--verbose>

Repeat this option to display more detailed information.

=item B<-h> | B<--help>

Display a breif help page and exit(0).

=item B<--version>

Display a short version information and exit(0).

=back

=head1 EXAMPLES

=over 4

=item Show help

    catme --help

=back

=head1 ENVIRONMENT

=over 8

=item TEMP, TMP

TEMP(or TMP, if $TEMP directory isn't existed) directory used to create
temporary files.

=back

=cut
sub _help {
    &_version;
    print "\nSyntax: \n    $0 [OPTION] [--] ...\n", <<'EOM';

Common options:
    -q, --quiet             Repeat to get less info
    -v, --verbose           Repeat to get more info
    -h, --help              Show this help page
        --version           Print the version info

Environment options:
    -L, --lib=PATH          Add to the library search path

Source format options:
    -c                      C-style comment
    -u, --unix              Unix-style comment (the default)
    -d, --dash-dash         Double dash (SQL-style) comment
EOM
}

exit (_boot or 0);

sub _main {
    for my $file (@ARGV) {
        my $base = $file;
            $base =~ s/^.*\///g;
        my $lastdot = rindex($base, '.');
        my $ext = $lastdot == -1 ? undef : substr($base, $lastdot + 1);

        @searchpath = @opt_searchpath;

        if (defined $ext) {
            for my $pathdir ("$opt_configdir/path/$ext", "$pkgdatadir/path/$ext") {
                next unless opendir(my $dh, $pathdir);

                my @files = grep { -f "$pathdir/$_" } readdir($dh);
                closedir $dh;

                for my $pathfile (@files) {
                    _log2 "Parse path file $pathdir/$pathfile...";
                    for (readfile("$pathdir/$pathfile")) {
                        chomp;
                        next unless -d $_;
                        _log3 "Add search path $_";
                        push @searchpath, $_;
                    }
                }
            }
        }

        my $lang = $langtab->{$ext};
        if (defined $lang) {
            my $libvar = uc($lang) . 'LIB';
            my $lib = $ENV{$libvar};
            if (defined $lib) {
                for (split(/:/, $lib)) {
                    _log2 "Add search path $_";
                    push(@searchpath, $_) if -d;
                }
            }
        }

        process($file);
    }
}

sub process {
    my ($file, @args) = @_;
    _log2 "Process $file";

    my $vars = {};
    my $argi = 0;
    for (@args) {
        $argi++;
        my $sep = index($_, ':=');
        my $k;
        if ($sep == -1) {
            $k = $argi;
        } else {
            $k = substr($_, 0, $sep);
            $_ = substr($_, $sep + 2);
        }
        $vars->{$k} = $_;
    }
    
    my ($dir, $base) = ($file, $file);
        if ($dir =~ s/\/[^\/]*$//) {
            $base =~ s/^.*\///;
        } else {
            $dir = '.';
        }
        push @dirstack, $dir;

    my ($name, $ext) = ($base, $base);
        if ($name =~ s/\.[^.]*$//) {
            $ext =~ s/^.*\.//;
        } else {
            $ext = undef;
        }
        push @extstack, $ext;

    my $fqn = ($dir eq '.') ? $name : "$dir/$name";
        $fqn =~ s/\//./g;

    my $delim = $opt_delim;
    unless (defined $delim) {
        my $lang = $langtab->{$ext};
        $delim = $lang_delim->{$lang};
        unless (defined $delim) {
            $delim = [ '#', '' ];
        }
        _log2 "Auto determined the delimiters from file extension.";
    }

    ($del, $der) = @$delim;
    $ndel = length($del);
    $nder = length($der);
    _log2 "Delimiter: $del($ndel), $der($nder)";

    my $err;
    my $fh = new FileHandle;
    $fh->open("<$file")
        or die "Can't open $file: $!";

    my $line = 0;
    while (<$fh>) {
        $line++;
        my $s = $_;
            $s =~ s/^\s+//;
            chomp $s;
        my $n = length($s);
        if ((substr($s, 0, $ndel) eq $del) and
                (substr($s, $n - $nder) eq $der)) {
            $s = substr($s, $ndel, $n - $nder);
            $s =~ s/^\s*//;
            if (substr($s, 0, 1) eq '\\') {
                print if $opt_keep;
                $err = parse($s);
                if ($err) {
                    _error "    at $file:$line";
                    last; # while <>
                } else {
                    next;
                }
            }
        }

        $_ = expand_line($_, $vars);
        print;
    }

    $fh->close();

    pop @extstack;
    pop @dirstack;
    return $err;
}

sub expand_line($$) {
    my ($s, $vars) = @_;
    $s =~ s/\$(\d+|\w[A-Za_z0-9_\$]*)/expand_bare($1, $vars)/ge;
    $s =~ s/\$\{([^{]+)\}/expand_brace($1, $vars)/ge;
    return $s;
}

sub expand_bare($$) {
    my ($expr, $map) = @_;
    my $val = expand_expr($expr, $map);
    if (defined $val) {
        return $val;
    } else {
        return '$'.$expr;
    }
}

sub expand_brace($$) {
    my ($expr, $map) = @_;
    my $val = expand_expr($expr, $map);
    if (defined $val) {
        return $val;
    } else {
        return '${'.$expr.'}';
    }
}

sub expand_expr($$) {
    my ($expr, $map) = @_;
    my $pad = 0;
    my $defl = undef;
    while (1) {
        if ($expr =~ s/:=(.*)$//) {
            my $setval = expand_line($1, $map);
            $map->{$expr} = $setval;
            return '';
        }
        if ($expr =~ s/\[(\d+)\]//) {
            $pad = $1;
            next;
        }
        if ($expr =~ s/=(.*)//) {
            $defl = $1;
            next;
        }
        last;
    }

    my $val = $map->{$expr};
    $val = $defl unless defined $val;

    if ($pad != 0) {
        $val .= ' ' while (length($val) < $pad);
    }
    return $val;
}

sub parse {
    for (@_) {
        my $s = $_;
        if ($s =~ /^\\([a-z\-]+)\b\s*(.*)$/) {
            my $cmd = "$1";
            my @args = split(/\s+/, $2);
            my $code = $cmds->{$cmd};
            unless (defined $code) {
                _error "Illegal command: $cmd";
                return 1;
            }
            my $err = $code->(@args);
            return $err if $err;
        }
    }
    return 0;
}

=head1 DIAGNOSTICS

(No Information)

=cut
# (HELPER FUNCTIONS)
sub fqn2href {
    my @v;
    my $ext = $extstack[-1];
    for (@_) {
        s/\./\//g;
        push @v, "$_.$ext";
    }
    return @v;
}

sub search {
    my $base = shift;
    my @v;

    for my $dir (@_) {
        my $file = "$dir/$base";
        if (-f $file) {
            push @v, $file;
        }
    }
    return @v;
}

=head1 HACKING

(No Information)

=cut
# (MODULE FUNCTIONS)
my $imported = {};

sub fn_dnl {
    return 0;
}

sub _fn_import {
    my ($once, $fqn, @args) = @_;
    if ($once and defined $imported->{$fqn}) {
        _log2 "already imported: $fqn";
        return 0;
    }
    $imported->{$fqn} = 1;

    my ($href) = fqn2href($fqn);
    my @v = search($href, @searchpath);
    if (scalar(@v) == 0) {
        _error "Import failed, not found: $href.";
        _error "    search $_" for @searchpath;
        return 1;
    }

    my $dst = $v[0];
    process($dst, @args);
}

sub fn_import {
    _fn_import(1, @_);
}

sub fn_mixin {
    _fn_import(0, @_);
}

sub _fn_include {
    my ($silent, $href, @args) = @_;

    my $workdir = $dirstack[-1];
    my @v = search($href, $workdir, @searchpath);
    if (scalar(@v) == 0) {
        if ($silent) {
            return 0;
        } else {
            _error "Include failed, not found: $href.";
            return 1;
        }
    }

    my $dst = $v[0];
    process($dst, @args);
}

sub fn_include {
    _fn_include(0, @_);
}

sub fn_sinclude {
    _fn_include(1, @_);
}

=head1 HISTORY

=over

=item 0.x

The initial version.

=back

=cut
sub _version {
    print "[$LOGNAME] Stupid Text Concatenater\n";
    print "Written by Lenik,  Version 0.$RCSID{rev},  Last updated at $RCSID{date}\n";
}

=head1 SEE ALSO

The L<cmt/"Perl_simple_cli_program_template">

=head1 AUTHOR

Lenik <lenik at bodz.net>

=cut
