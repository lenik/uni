#!/usr/bin/perl

=head1 NAME

catme - Stupid Text Concatenater

=cut
use strict;
use vars qw($LOGNAME $LOGLEVEL);
use cmt::log(2);
    $LOGNAME    = 'catme'; # $0 =~ /([^\/\\.]+)(?:\.\w+)*$/;
use cmt::path('path_split');
use cmt::util('readfile');
use cmt::vcs('parse_id');
    my %RCSID   = parse_id('$Id: - @VERSION@ @DATE@ @TIME@ - $');
use FileHandle;
use Getopt::Long;
    Getopt::Long::Configure('gnu_getopt');

sub _main; sub _version; sub _help;

my $opt_configdir = $ENV{HOME} . "/.config/catme";
my @opt_searchpath = ('.');
my $opt_delim;
my $opt_keep = 0;

my @dirstack = ();
my @searchpath;
my $ext_delim = {
        '.sql' => [ '--', '' ],
    };
my ($sbegin, $send);
my ($nbegin, $nend);
my @extstack;

my $cmds = {
    'import' => \&fn_import,
    'include' => \&fn_include,
    'mixin' => \&fn_mixin,
    'sinclude' => \&fn_sinclude,
};

sub _boot {
    GetOptions('q|quiet'        => sub { $LOGLEVEL-- },
               'v|verbose'      => sub { $LOGLEVEL++ },
               'version'        => sub { _version; exit 0 },
               'h|help'         => sub { _help; exit 0 },
               'L|lib=s'        => \@opt_searchpath,
               'c'              => sub { $opt_delim = [ '/*', '*/' ] },
               'u|unix'         => sub { $opt_delim = [ '#', '' ] },
               'd|dash-dash'    => sub { $opt_delim = [ '--', '' ] },
               'k|keep'         => \$opt_keep,
               )
        or exit(1);

    my $lib = $ENV{'LIB'};
    if (defined $lib) {
        for my $item (split(/:/, $lib)) {
            next if $item eq '';
            push @opt_searchpath, $item;
        }
    }
    
    for my $path (@opt_searchpath) {
        _log2 "Search: $path";
    }

    _main;
}

=head1 SYNOPSIS

B<catme>
    S<[ B<-q> | B<--quiet> ]>
    S<[ B<-v> | B<--verbose> ]>
    S<[ B<-h> | B<--help> ]>
    S<[ B<--version> ]>
    S<[ B<--> ]>
    S<[ I<...the rest of arguments...> ]>

=head1 DESCRIPTION

B<catme> is a WHAT used for WHAT. It HOW-WORKS.

BACKGROUND-PROBLEM.

HOW-catme-RESOLVES.

=head1 OPTIONS

=over 8

=item B<-m> | B<--my-option>

...

=item B<-q> | B<--quiet>

Repeat this option to suppress unimportant information to display.

=item B<-v> | B<--verbose>

Repeat this option to display more detailed information.

=item B<-h> | B<--help>

Display a breif help page and exit(0).

=item B<--version>

Display a short version information and exit(0).

=back

=head1 EXAMPLES

=over 4

=item Show help

    catme --help

=back

=head1 ENVIRONMENT

=over 8

=item TEMP, TMP

TEMP(or TMP, if $TEMP directory isn't existed) directory used to create
temporary files.

=back

=cut
sub _help {
    &_version;
    print "\nSyntax: \n    $0 [OPTION] [--] ...\n", <<'EOM';

Common options:
    -q, --quiet             Repeat to get less info
    -v, --verbose           Repeat to get more info
    -h, --help              Show this help page
        --version           Print the version info

Environment options:
    -L, --lib=PATH          Add to the library search path

Source format options:
    -c                      C-style comment
    -u, --unix              Unix-style comment (the default)
    -d, --dash-dash         Double dash (SQL-style) comment
EOM
}

exit (_boot or 0);

sub _main {
    for my $file (@ARGV) {
        process($file);
    }
}

sub process {
    my ($file, $range) = @_;
    _log2 "Process $file";

    my ($dir, $base) = ($file, $file);
        if ($dir =~ s/\/[^\/]*$//) {
            $base =~ s/^.*\///;
        } else {
            $dir = '.';
        }
        push @dirstack, $dir;

    my ($name, $ext) = ($base, $base);
        if ($name =~ s/\.[^.]*$//) {
            $ext =~ s/^.*\.//;
            $ext = ".$ext";
        } else {
            $ext = '';
        }
        push @extstack, $ext;

    my $fqn = ($dir eq '.') ? $name : "$dir/$name";
        $fqn =~ s/\//./g;

    my $delim = $opt_delim;
    unless (defined $delim) {
        $delim = $ext_delim->{$ext};
        unless (defined $delim) {
            $delim = [ '#', '' ];
        }
        _log2 "Auto determined the delimiters from file extension.";
    }

    ($sbegin, $send) = @$delim;
    $nbegin = length($sbegin);
    $nend = length($send);
    _log2 "Delimiter: $sbegin($nbegin), $send($nend)";

    @searchpath = @opt_searchpath;
        my $pathcfg = "$opt_configdir/path$ext";
        if (-f $pathcfg) {
            for (readfile($pathcfg)) {
                chomp;
                push @searchpath, $_;
            }
        }

    my $err;
    my $fh = new FileHandle;
    $fh->open("<$file")
        or die "Can't open $file: $!";

    my $line = 0;
    while (<$fh>) {
        $line++;
        my $s = $_;
            $s =~ s/^\s+//;
            chomp $s;
        my $n = length($s);
        if ((substr($s, 0, $nbegin) eq $sbegin) and
                (substr($s, $n - $nend) eq $send)) {
            $s = substr($s, $nbegin, $n - $nend);
            $s =~ s/^\s*//;
            if (substr($s, 0, 1) eq '\\') {
                print if $opt_keep;
                $err = parse($s);
                if ($err) {
                    _error "    at $file:$line";
                    last; # while <>
                } else {
                    next;
                }
            }
        }
        print;
    }

    $fh->close();

    pop @extstack;
    pop @dirstack;
    return $err;
}

sub parse {
    for (@_) {
        my $s = $_;
        if ($s =~ /^\\([a-z\-]+)\b\s*(.*)$/) {
            my $cmd = "$1";
            my @args = split(/\s+/, $2);
            my $code = $cmds->{$cmd};
            unless (defined $code) {
                _error "Illegal command: $cmd";
                return 1;
            }
            my $err = $code->(@args);
            return $err if $err;
        }
    }
    return 0;
}

=head1 DIAGNOSTICS

(No Information)

=cut
# (HELPER FUNCTIONS)
sub fqn2href {
    my @v;
    my $ext = $extstack[-1];
    for (@_) {
        s/\./\//g;
        push @v, "$_$ext";
    }
    return @v;
}

sub search {
    my $base = shift;
    my @v;

    for my $dir (@_) {
        my $file = "$dir/$base";
        if (-f $file) {
            push @v, $file;
        }
    }
    return @v;
}

=head1 HACKING

(No Information)

=cut
# (MODULE FUNCTIONS)
my $imported = {};

sub _fn_import {
    my ($once, $fqn, $range) = @_;
    if ($once and defined $imported->{$fqn}) {
        _log2 "already imported: $fqn";
        return 0;
    }
    $imported->{$fqn} = 1;

    my ($href) = fqn2href($fqn);
    my @v = search($href, @searchpath);
    if (scalar(@v) == 0) {
        _error "Import failed, not found: $href.";
        _error "    search $_" for @searchpath;
        return 1;
    }

    my $dst = $v[0];
    process($dst, $range);
}

sub fn_import {
    _fn_import(1, @_);
}

sub fn_mixin {
    _fn_import(0, @_);
}

sub _fn_include {
    my ($silent, $href, $range) = @_;

    my $workdir = $dirstack[-1];
    my @v = search($href, $workdir, @searchpath);
    if (scalar(@v) == 0) {
        if ($silent) {
            return 0;
        } else {
            _error "Include failed, not found: $href.";
            return 1;
        }
    }

    my $dst = $v[0];
    process($dst, $range);
}

sub fn_include {
    _fn_include(0, @_);
}

sub fn_sinclude {
    _fn_include(1, @_);
}

=head1 HISTORY

=over

=item 0.x

The initial version.

=back

=cut
sub _version {
    print "[$LOGNAME] Stupid Text Concatenater\n";
    print "Written by Lenik,  Version 0.$RCSID{rev},  Last updated at $RCSID{date}\n";
}

=head1 SEE ALSO

The L<cmt/"Perl_simple_cli_program_template">

=head1 AUTHOR

Lenik <lenik at bodz.net>

=cut
