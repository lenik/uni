#!/bin/bash
    : ${RCSID:=$Id: - @VERSION@ @DATE@ @TIME@ - $}
    : ${PROGRAM_TITLE:="Rsync for site mirroring"}
    : ${PROGRAM_SYNTAX:="[OPTIONS] [--] module[/path]"}

    . shlib-import cliboot
    option -d --delete      "Do rsync delete"
    option -p --page =SIZE  "Split to pages by size [2^SIZE..2^SIZE+3)"
    option -r --repeat =TIMEOUT "Repeat rsync after TIMEOUT"
    option -s --server =SERVER "Specify the server to use"
    option -q --quiet       "Repeat to get less info"
    option -v --verbose     "Repeat to get more info"
    option -h --help        "Show this help page"
    option    --version     "Print the version info"

    shopt -s nullglob

function setopt() {
    case "$1" in
        -d|--delete)
            delete=1;;
        -r|--repeat)
            repeat=$2;;
        -s|--server)
            server="$2";;
        -p|--page)
            page="$2";;
        -h|--help)
            help; exit;;
        -q|--quiet)
            LOGLEVEL=$((LOGLEVEL - 1));;
        -v|--verbose)
            LOGLEVEL=$((LOGLEVEL + 1));;
        --version)
            version; exit;;
        *)
            quit "invalid option: $1";;
    esac
}

function main() {
    if [ -n "$page" -a "$delete" = 1 ]; then
        echo "WARNING: "
        echo "When size-filter is specified, delete option will remove all files"
        echo "out of the specified size range. "
        echo "Are you really want to do that? (y/N)"
        read confirm
        if [ "$confirm" != y -a "$confirm" != yes ]; then exit 1; fi
    fi

    m_dir="$1"
        # chop the ending '/'
        if [ "${m_dir: -1}" = / ]; then m_dir="${m_dir%/}"; fi

    m_mod="${m_dir%%/*}"
        if [ "$m_mod" = "$m_dir" ]; then
            m_dir=
        else
            m_dir="${m_dir#*/}"
        fi

    s_index=$RANDOM
    if [ "$server" = $((server+0)) ]; then
        s_index=$server
        server=
    fi

    # server isn't specified, guess one by mod-name
    if [ -z "$server" ]; then
        # find servers contain $m_mod. /dev/null if no files under servers/
        svr_list=(`grep -l \\\\\\[$m_mod\\\\\\] /dev/null {.,~}/.msync/srv/* 2>/dev/null`)
        svr_count=${#svr_list[@]}
        if [ $svr_count = 0 ]; then
            echo no available server.
            exit 1
        fi
        svr_conf=${svr_list[s_index % svr_count]}
        server=${svr_conf##*/}
    else
        # server name is specified, search svr_conf file
        for f in {.,~}/.msync/srv/$server; do
            if [ -f $f ]; then
                svr_conf=$f
                break
            fi
        done
        ## empty path '' will fail the -f test.
        # if [ -z "$svr_conf" ]; then
        #     echo "server $server isn't defined."
        #     exit 1
        # fi
    fi

    # load server config, example:
    #   cpan.server.com 122100 21220
    #
    #   [CPAN]
    #   path=pub/CPAN
    #   username=USER
    #   password=PASSWORD
    #
    #   [ubuntu]
    #   path=pub/ubuntu
    if [ -f "$svr_conf" ]; then
        read r_host r_down r_up <$svr_conf
        parse_attr=0
        line=0
        while read LINE; do
            ((line++))
            if [ -z "$LINE" ]; then continue; fi
            if [ "${LINE:0:1}" = '#' ]; then continue; fi
            if [ "${LINE:0:1}" = '[' -a "${LINE: -1}" = ']' ]; then
                mdef="${LINE:1:${#LINE}-2}"
                if [ "$m_mod" = "$mdef" ]; then
                    parse_attr=1
                else
                    parse_attr=0
                fi
                continue
            fi
            if [ "$parse_attr" != 1 ]; then continue; fi

            # Parse Attributes
            if [ "${LINE//=}" = "$LINE" ]; then
                echo "Illegal usage in $svr_conf:$line: $LINE"
                exit 1
            fi
            m_key="${LINE%%=*}"
            m_value="${LINE#*=}"
            echo "Module-Attribute: $m_key = $m_value"
            eval "r_${m_key}=\"$m_value\""
        done <$svr_conf

        if [ -z "$r_path" ]; then
            # [MODULE] without path= attribute, default path=MODULE
            r_path="$m_mod"
        fi
    else
        r_host=$server
        r_path=$m_mod
    fi
    remotedir=$r_path
    if [ -n "$m_dir" ]; then remotedir="$remotedir/$m_dir"; fi

    # -a = -rlptgoD
    #   --recursive
    #   --links     copy symlinks as symlinks
    #   --perms     preserve permissions
    #   --times     preserve modification times
    #   --group, -owner
    #   --devices, --specials (-D)
    #   --prune-empty-dirs (-m)
    ropts=-amv
    if [ "$delete" = 1 ]; then ropts="$ropts --delete --delete-excluded"; fi

    # load alias config, example:
    # ubuntu
    for conf in {.,~}/.msync; do
        if [ -f $conf/mod/$m_mod ]; then
            while read a_opt a_val; do
                case "$a_opt" in
                    *)
                        echo bad option: $a_opt
                        exit 2;;
                esac
            done <$conf/mod/$m_mod
        fi

        if [ -f $conf/mod/$m_mod.ex ]; then
            ropts="$ropts --exclude-from $conf/mod/$m_mod.ex"
        fi

        if [ -f $conf/mod/$m_mod.in ]; then
            ropts="$ropts --include-from $conf/mod/$m_mod.in"
        fi
    done

    case "$page" in
    '') ;;
    1)  ropts="$ropts --max-size=2m-1";;
    4)  ropts="$ropts --max-size=16m-1";;
    7)  ropts="$ropts --min-size=16m --max-size=1g-1";;
    10) ropts="$ropts --min-size=1g";;
    *)  echo illegal page: $page; exit 3;;
    esac

    localdir="$m_mod"
    if [ -n "$m_dir" ]; then
        _base="${m_dir##*/}"
        if [ "$_base" == "$m_dir" ]; then
            _dir=""
        else
            _dir="${m_dir%/*}"
        fi
        if [ "${_base/[\*\?]/}" != "$_base" ]; then
            # basename contains *, ? wildcards, using the parent of m_dir
            localdir="$localdir/$_dir"
        else
            localdir="$localdir/$m_dir"
            remotedir="$remotedir/"
        fi
    fi
    mkdir -p "$localdir"

    logf="$localdir"
    logf="${logf//[\*\?]/_}"
    logf="${logf//[\/\\]/_}"
    logf="/var/log/rsync/$logf"
    ropts="$ropts --log-file=$logf.log"

    # if r_host contains '/', it is absolute name, otherwise add rsync:// to it.
    if [ "${r_host/\/}" = "$r_host" ]; then
        r_hostconn="$r_host"

        if [ -n "$r_username" ]; then
            r_hostconn="$r_username@$r_host"
        fi

        if [ -n "$r_password" ]; then
            export RSYNC_PASSWORD="$r_password"
        fi

        r_host="rsync://$r_hostconn"
    fi

    #echo "options:  $ropts"
    #echo "remote:   $r_host/$remotedir"
    #echo "local:    $localdir"

    while true; do
        _log1 "rsync $ropts $r_host/$remotedir ($PWD/) $localdir"
        rsync $ropts "$r_host/$remotedir" "$localdir"
        rsync_err=$?

        if [ -z "$repeat" ]; then break; fi
        echo Press CTRL-C to exit, or repeat this task after $repeat seconds...
        read -n 1 -t $repeat KEY
    done

    echo "Done: $@"
    if [ -f "$logf.log" ]; then
        mv -f "$logf.log" "$logf.done"
    fi

    return $rsync_err
}

boot "$@"
