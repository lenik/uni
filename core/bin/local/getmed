#!/usr/bin/perl
# $Id: getmed,v 1.4 2005-04-17 10:21:42 dansei Exp $

use strict;
use DirHandle;
use Getopt::Long;


our @name_pats = (
	qr/\s*(?:href|src)\s*=\s*\"([^\"]+)\"/,
	qr/\s*(?:href|src)\s*=\s*\'([^\']+)\'/,
	qr/\s*(?:href|src)\s*=([^\"\']\S*)/,
	qr/(http:\/\/[^\"\' \t\n]+)/,
	qr/(ftp:\/\/[^\"\' \t\n]+)/,
	qr/\"([^\"]+)\"/,
	qr/\'([^\']+)\'/,
	);

our @name_pats_rec = (
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    );

our @name_valids = (
	qr/\.wma$/,
	qr/\.mp3$/,
	qr/\.avi$/,
	qr/\.rm$/,
	qr/\.ra$/,
	qr/\.rmvb$/,
	qr/\.ape$/,
	);


my ($upat, $npat);

my @urls;
my $filename;


our $opt_keep = 0;
our $opt_file_prefix = 0;


sub main();
sub help();
sub parse_file;

    GetOptions(
	'ext=s'			=> sub { push @name_valids, qr/\.$_[1]$/ },
	'regex=s'		=> sub { push @name_valids, qr/$_[1]/ },
	'keep',
	'file-prefix',
	'help'			=> \&help,
	);


main();



sub help() {
	print <<"EOM";
[GETMED] get media URLs from input
syntax:
	$0
	--help --keep --nokeep
	--file-prefix
	--ext=<explicit ext-name>
	--regex=<reg-exp to full-name>

version: 1
	this program is distributed under GPL license.
EOM
	exit -1;
}


sub main() {
	my ($dh, @files);
	$dh = new DirHandle '.';
	@files = $dh->read();

	foreach (@files) {
		next if not -f;
		parse_file $_;
		unlink if not $opt_keep;
	}

	# print join("\n", @urls);

	# copy to clipboard
	use Win32::Clipboard;
	my $clip = Win32::Clipboard();
	$clip->Set(join("\r\n", @urls));
}


sub parse_buffer {
    my $line = shift @_;

	my $rightmost = 0;

	for (my $i = 0; $i < scalar(@name_pats); $i++) {
	    my $upat = $name_pats[$i];
	    my $rec = $name_pats_rec[$i];

		while ($line =~ m/$upat/) {
			$line = substr($line, 0, $-[0])
			      . substr($line, $-[0]+length($&));
		    $rightmost = $-[0];

			my $seg = $1;
			# print "[$seg]\n";

			my $matched = 0;
			foreach $npat (@name_valids) {
				if ($seg =~ m/$npat/) {
					push @urls, $seg;
					printf("%16s: ", $filename) if $opt_file_prefix;
					print "$seg\n";
					$matched = 1;
					last;
				}
			}

			if ($matched == 0 && $rec == 1) {
			    # print ">>>>";
			    parse_buffer($seg);
			}

		}
	}

	return substr($line, $rightmost);
}


sub parse_file {
	my $text;

	$filename = shift @_;

	if (open FH, "<$filename") {
		while (<FH>) {
			chop;
			$text.=$_;
			if (length($text)>1000) {
			    $text = parse_buffer($text);
			}
		}
		close FH;
	} else {
		print STDERR "Can't open file $filename: $!";
	}
}
