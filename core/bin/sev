#!perl

use strict;
use cmt::vcs;
use Getopt::Long;

sub boot;
sub main;
sub add_decl;
sub add_braced_text;
sub info;
sub version;
sub help;

our $opt_sev_tag = 'self-evolution';
our $opt_mark = '*';
our $opt_decl = '%';
our $opt_preload = 1;                   # currently, streaming isn't supported.
our $opt_save = 1;
our $opt_verbose = 1;

my %marks;                              # $name => $line_no
my %decls;                              # $name => $decl_body

sub escape_regex {
    my $t = shift;
    $t =~ s/([?*+{}()\[\]\\])/\\$1/g;
    return $t;
}

sub boot {
    GetOptions('mark=s',
               'decl=s',
               'preload' => sub { $opt_preload++ },
               'save!',
               'quiet'   => sub { $opt_verbose-- },
               'verbose' => sub { $opt_verbose++ },
               'version' => sub { version; exit },
               'help'    => sub { help; exit },
               );

    $opt_mark = escape_regex $opt_mark;
    $opt_decl = escape_regex $opt_decl;
    info "mark symbol in regex: $opt_mark";
    info "decl symbol in regex: $opt_decl";

    if (@ARGV) {
        for my $file (@ARGV) {
            info "load file $file";
            open(FH, "<$file")
                or die "Cannot open file $file to read";
            my @lines = <FH>;
            my $ok = main \@lines;
            close FH;

            if ($ok ne 'ok') {
                info "load fails: $ok";
                next;
            }

            if ($opt_save == 1) {
                info "save file $file";
                open(FH, ">$file")
                    or die "Cannot open file $file to write";
                print FH for @lines;
                close FH;
            } else {
                print for @lines;
            }
        }
    } else {
        my @lines = <>;
        print @lines;
        my $ok = main \@lines;
        if ($ok ne 'ok') {
            info "load fails: $ok";
            return;
        }
        print for @lines;
    }
}

sub main {
    my $src = shift;                    # \@srclines
    %marks = ();
    %decls = ();

    my $name;
    my $body;                           # $decl_body
    my $brace = 0;                      # level of open-brace '{'

    # preloading
    info 'preloading...';
    my $srclines = scalar(@$src);
    for (my $i = 0; $i < $srclines; $i++) {
        $_ = $src->[$i];
        if (m/${opt_mark}(\w+)/) {
            my $name = $1;
            $marks{$name} = $i;
        }
        if ($brace == 0) {
            if (m/${opt_decl}(\w+)/) {
                $name = $1;
                my $init = substr($_, $+[0]);
                my $text;
                # 1, %name <text-only>
                # 2, %name <mixed-text { .{}.. }> ...
                # 3, %name <mixed-text { ...>
                ($text, $brace) = add_braced_text($init, $brace);
                $body = $text;
                if ($brace == 0) {
                    # $_ = substr($_, length($text));
                    add_decl $name, $body;
                }
            }
        } else {
            my $text;
            # 1, <text-only>
            # 2, <... }> ...
            # 3, < .{}...>
            # 4, <... { ..>
            ($text, $brace) = add_braced_text($_, $brace);
            $body .= $text;
            if ($brace == 0) {
                # $_ = substr($_, length($text));
                add_decl $name, $body;
            }
        }
    }

    info "mark $_: line " . $marks{$_} for (keys %marks);
    info "decl $_ = " . $decls{$_} for (keys %decls);

    for (keys %marks) {
        my $line_no = $marks{$_};
        my $decl = $decls{$_};
        next if not defined $decl;

        my $line = $src->[$line_no];
        $_ = $line;
        eval($decl);
        $src->[$line_no] = $_;
    }

    return 'ok';
}

sub add_decl {
    my ($name, $body) = @_;
    if ($name eq 'EVAL') {
        eval($body);
    }
    $decls{$name} = $body;
}

sub add_braced_text {
    my ($line, $br) = @_;
    my $text = $line;
    while ($line =~ m/[\{\}]/g) {
        my $inc = $& eq '{' ? 1 : -1;
        last if ($br == 0 && $inc == -1);
        $br += $inc;
        if ($br == 0) {
            # assert $& eq '}'
            $text = substr($line, 0, $+[0]);
        }
    }
    # $line_rest = substr($line, length($text))
    return ($text, $br);
}

sub info {
    return if $opt_verbose < 1;
    my $text = shift;
    print STDERR "[sev] $text\n";
}

sub version {
    my %id = parse_id('$Id: sev,v 1.2 2006-11-18 09:16:06 lenik Exp $');
    print "[sev, modself] Self Evolution, self-editing scripts\n";
    print "Written by Lenik   Version $id{rev}   Last updated at $id{date}\n";
}

sub help {
    version;
    print <<"EOM";

Syntax:
    $0 <options> files...

Options:
    --mark=<mark-symbol>     the symbol used to mark line of name
    --decl=<decl-symbol>     the symbol used to declare function of name
    --preload                load all content before process (2 steps).
    --nosave                 print instead of save itself
    --quiet
    --verbose
    --version
    --help
EOM
}

boot;
