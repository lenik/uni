#!/bin/bash
    RCSID='$Id: .sh 872 2008-10-29 11:51:30Z lenik $'
    short_opts="dhp:qr:s:v"
    long_opts="delete,help,page,repeat,quiet,server,verbose,version"
    . /lam/kala/lib/sh/cliboot
    shopt -s nullglob

function version() {
    parse_id "$RCSID"
    echo "[$BASENAME] Rsync for site mirroring"
    echo Written by Lenik, Version 0.$rcs_rev, Last updated at $rcs_date
}

function help() {
    version
    echo
    echo "Syntax: "
    echo "    $0 [OPTION] [--] module[/path]"
    echo
    echo "Options: "
    echo "    -d, --delete            do rsync delete"
    echo "    -p, --page=SIZE         split to pages by size [2^SIZE..2^SIZE+3)"
    echo "    -r, --repeat=TIMEOUT    repeat rsync after TIMEOUT"
    echo "    -s, --server=SERVER     specify the server to use"
    echo "    -q, --quiet             repeat to get less info"
    echo "    -v, --verbose           repeat to get more info"
    echo "    -h, --help              show this help page"
    echo "        --version           print the version info"
}

function setopt() {
    case "$1" in
        -d|--delete)
            delete=1;;
        -r|--repeat)
            repeat=$2;;
        -s|--server)
            server="$2";;
        -p|--page)
            page="$2";;
        -h|--help)
            help; exit;;
        -q|--quiet)
            LOGLEVEL=$((LOGLEVEL - 1));;
        -v|--verbose)
            LOGLEVEL=$((LOGLEVEL + 1));;
        --version)
            version; exit;;
        *)
            quit "invalid option: $1";;
    esac
}

function main() {
    if [ -n "$page" -a "$delete" = 1 ]; then
        echo "WARNING: "
        echo "When size-filter is specified, delete option will remove all files"
        echo "out of the specified size range. "
        echo "Are you really want to do that? (y/N)"
        read confirm
        if [ "$confirm" != y -a "$confirm" != yes ]; then exit 1; fi
    fi

    m_dir="$1"
        # chop the ending '/'
        if [ "${m_dir: -1}" = / ]; then m_dir="${m_dir%/}"; fi

    m_mod="${m_dir%%/*}"
        if [ "$m_mod" = "$m_dir" ]; then
            m_dir=
        else
            m_dir="${m_dir#*/}"
        fi

    s_index=$RANDOM
    if [ "$server" = $((server+0)) ]; then
        s_index=$server
        server=
    fi

    # server isn't specified, guess one by mod-name
    if [ -z "$server" ]; then
        # find servers contain $m_mod. /dev/null if no files under servers/
        svr_list=(`grep -l ^$m_mod= /dev/null {.,~}/.msync/srv/* 2>/dev/null`)
        svr_count=${#svr_list[@]}
        if [ $svr_count = 0 ]; then
            echo no available server.
            exit 1
        fi
        svr_conf=${svr_list[s_index % svr_count]}
        server=${svr_conf##*/}
    else
        # server name is specified, search svr_conf file
        for f in {.,~}/.msync/srv/$server; do
            if [ -f $f ]; then
                svr_conf=$f
                break
            fi
        done
        ## empty path '' will fail the -f test.
        # if [ -z "$svr_conf" ]; then
        #     echo "server $server isn't defined."
        #     exit 1
        # fi
    fi

    # load server config, example:
    #   cpan.server.com 122100 21220
    #   CPAN=pub/CPAN
    #   ubuntu=pub/ubuntu
    if [ -f "$svr_conf" ]; then
        read r_host r_down r_up <$svr_conf
        mdef=`grep ^$m_mod= $svr_conf`
        r_path="${mdef#*=}"
    else
        r_host=$server
        r_path=$m_mod
    fi
    remotedir=$r_path
    if [ -n "$m_dir" ]; then remotedir="$remotedir/$m_dir"; fi

    # -a = -rlptgoD
    #   --recursive
    #   --links     copy symlinks as symlinks
    #   --perms     preserve permissions
    #   --times     preserve modification times
    #   --group, -owner
    #   --devices, --specials (-D)
    #   --prune-empty-dirs (-m)
    ropts=-amv
    if [ "$delete" = 1 ]; then ropts="$ropts --delete --delete-excluded"; fi

    # load alias config, example:
    # ubuntu
    for conf in {.,~}/.msync; do
        if [ -f $conf/mod/$m_mod ]; then
            while read a_opt a_val; do
                case "$a_opt" in
                    *)
                        echo bad option: $a_opt
                        exit 2;;
                esac
            done <$conf/mod/$m_mod
        fi

        if [ -f $conf/mod/$m_mod.ex ]; then
            ropts="$ropts --exclude-from $conf/mod/$m_mod.ex"
        fi

        if [ -f $conf/mod/$m_mod.in ]; then
            ropts="$ropts --include-from $conf/mod/$m_mod.in"
        fi
    done

    case "$page" in
    '') ;;
    1)  ropts="$ropts --max-size=2m-1";;
    4)  ropts="$ropts --max-size=16m-1";;
    7)  ropts="$ropts --min-size=16m --max-size=1g-1";;
    10) ropts="$ropts --min-size=1g";;
    *)  echo illegal page: $page; exit 3;;
    esac

    localdir="$m_mod"
    if [ -n "$m_dir" ]; then
        _base="${m_dir##*/}"
        if [ "$_base" == "$m_dir" ]; then
            _dir=""
        else
            _dir="${m_dir%/*}"
        fi
        if [ "${_base/[\*\?]/}" != "$_base" ]; then
            # basename contains *, ? wildcards, using the parent of m_dir
            localdir="$localdir/$_dir"
        else
            localdir="$localdir/$m_dir"
            remotedir="$remotedir/"
        fi
    fi
    mkdir -p "$localdir"

    logf="$localdir"
    logf="${logf//[\*\?]/_}"
    logf="${logf//[\/\\]/_}"
    logf="/var/log/rsync/$logf"
    ropts="$ropts --log-file=$logf.log"

    # if r_host contains '/', it is absolute name.
    if [ "${r_host/\/}" = "$r_host" ]; then
        r_host="rsync://$r_host"
    fi

    #echo "options:  $ropts"
    #echo "remote:   $r_host/$remotedir"
    #echo "local:    $localdir"

    while true; do
        _log1 "rsync $ropts $r_host/$remotedir ($PWD/) $localdir"
        rsync $ropts "$r_host/$remotedir" "$localdir"
        rsync_err=$?

        if [ -z "$repeat" ]; then break; fi
        echo Press CTRL-C to exit, or repeat this task after $repeat seconds...
        read -n 1 -t $repeat KEY
    done

    echo "Done: $@"
    if [ -f "$logf.log" ]; then
        mv -f "$logf.log" "$logf.done"
    fi

    return $rsync_err
}

boot "$@"
