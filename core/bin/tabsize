#!/usr/bin/perl

use strict;
use cmt::path;
use cmt::util;
use cmt::vcs;
use DirHandle;
use Getopt::Long;

sub boot;
sub findfile;
sub dirproc;
sub fileproc;
sub main;

sub mesg;
sub info;
sub info2;
sub version;
sub help;

our $opt_verbtitle      = 'tabsize';
our $opt_verbtime       = 0;
our $opt_verbose        = 1;
our $opt_recursive      = 1;
our @opt_and_test       = ();
our @opt_xor_test       = ();
our $opt_dir            = 0;
our $opt_dir_only       = 0;
our $opt_include_hiddens= 0;
our @opt_files          = ();
our $opt_writeback      = 0;
our $opt_old_tabsize    = 8;
our $opt_new_tabsize    = 4;
our $opt_min_tabsize    = 2;
our $opt_tabify         = 0;    # 0: using space instead.

our $stat_total         = 0;
our $stat_proc          = 0;

sub boot {
    GetOptions('quiet|q'        => sub { $opt_verbose-- },
               'verbose|v'      => sub { $opt_verbose++ },
               'version'        => sub { version; exit },
               'help|h'         => sub { help; exit },
               'recursive|r'    => sub { $opt_recursive = 100 },
               'and-test|at=s'  => \@opt_and_test,
               'xor-test|xt=s'  => \@opt_and_test,
               'dir|d',
               'dir-only|do',
               'include-hiddens|ih',
               'writeback|w',
               'old-tabsize|o=i',
               'new-tabsize|n=i',
               'min-tabsize|m=i',
               'tabify|t',
               );
    $opt_dir = 1 if $opt_dir_only;

    @opt_files = @ARGV;
    unless (@opt_files) {
        die("No file specified. ");
    }

    @opt_and_test = map \&qg, @opt_and_test;
    @opt_xor_test = map \&qg, @opt_xor_test;

    info2 "--and-test: $_" for @opt_and_test;
    info2 "--xor-test: $_" for @opt_xor_test;
    info2 "file: $_" for @opt_files;

    die 'tab-size must be positive number'
        if $opt_old_tabsize < 1
        or $opt_new_tabsize < 1
        or $opt_min_tabsize < 1;

    findfile($_, $opt_recursive) for @opt_files;

    info "Total $stat_proc / $stat_total files processed";

    return $stat_proc;
}

sub mesg {
    return if $opt_verbose < 1;
    my $text = shift;
    print cdatetime.' ' if $opt_verbtime;
    print "$text";
}

sub info {
    return if $opt_verbose < 1;
    my $text = shift;
    print cdatetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub info2 {
    return if $opt_verbose < 2;
    my $text = shift;
    print cdatetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub version {
    my %id = parse_id('$Id: tabsize,v 1.7 2007-11-08 10:52:38 lenik Exp $');
    print "[$opt_verbtitle] Adjust tab-style of plain text\n";
    print "Written by Lenik,  Version 0.$id{rev},  Last updated at $id{date}\n";
}

sub help {
    version;
    print <<"EOM";

Syntax:
        $0 <options> files...

Options:
        --quiet (q)
        --verbose (v, repeat twice give you more verbose info)
        --version
        --help (h)
        --recursive (r)
        --and-test=<pattern> (at, multiple tests are joined by 'or')
        --xor-test=<pattern> (xt, multiple tests are joined by 'or')
        --dir (d)
        --dir-only (do)
        --include-hiddens (ih)
        --writeback (w, default test-only)
        --old-tabsize=<size> (o, default 8)
        --new-tabsize=<size> (n, default 4)
        --min-tabsize=<size> (m, default 2)
EOM
}

exit (boot or 0);

sub findfile {
    my ($path, $recur) = @_;
    if (-d $path) {
        dirproc($path) if $opt_dir;
        if ($recur--) {
            my $dh = new DirHandle($path);
            my @files = $dh->read;
            $dh->close;
            for (@files) {
                next if /^\.+$/;
                next if /^\./ and !$opt_include_hiddens;
                my $base = $_;
                my $path2 = "$path/$_";
                if (@opt_and_test) {
                    my @passed = grep { $base =~ $_ } @opt_and_test;
                    next unless @passed;
                }
                if (@opt_xor_test) {
                    my @passed = grep { $base =~ $_ } @opt_xor_test;
                    next if @passed;
                }
                findfile($path2, $recur);
            }
        }
    } else {
        fileproc($path) unless $opt_dir_only;
    }
}

sub dirproc {
    my ($path) = @_;
    mesg "[dir/] $path/\n";
    $stat_total++;
    $stat_proc++ if main @_;
}

sub fileproc {
    my ($path) = @_;
    mesg "[file] $path";
    $stat_total++;
    $stat_proc++ if main @_;
    mesg "\n";
}

sub main {
    my $path = shift;
    return 0 unless -f $path;

    my @in = readfile($path);
    my @out;
    for my $lineno (0..$#in) {
        $_ = $in[$lineno];

        ############################## BEGIN ###########################
        my @chars = split('', $_);
        my ($i, $x) = (0, 0);

        foreach my $c (@chars) {
            if ($c eq "\t") {
                $c = ' 'x($opt_old_tabsize-$x);
                $chars[$i] = $c;
                $x = 0;
            } else {
                $x = ($x+1) % $opt_old_tabsize;
            }
            $i++;
        }
        $_ = join('', @chars);

        if ($opt_tabify) {
            my @segs;
            while (m/.{1,$opt_new_tabsize}/sg) {
                #assert no '\t' inside.
                my $seg = $&;
                if ($seg =~ m/( +)$/) {
                    if (length($1) >= $opt_min_tabsize) {
                        $seg =~ s/( +)$/\t/;
                    }
                }
                push @out, $seg;
            }
        } else {
            push @out, $_;
        }
        ##############################  END  ###########################

    }
    if (join('', @in) ne join('', @out)) {
        mesg "\r[save] $path";
        writefile($path, @out) if $opt_writeback;
        return 1;
    }
    print join('', @out) unless $opt_writeback;

    return 0;
}
