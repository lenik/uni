#!/usr/bin/perl

use strict;
use cmt::ftime;
use cmt::path;
use cmt::util;
use cmt::vcs;
use cmt::winuser;
use File::Copy qw/cp/;
use Getopt::Long;
use POSIX;
use Term::ReadKey;

sub boot;
sub main;
sub info;
sub info2;
sub version;
sub help;

sub fwait;
sub run;
sub get_text;
sub set_focus;
sub killpid;
sub quit;
sub do_keyq;
sub do_actq;

our $opt_verbtitle      = 'loop2';
our $opt_verbtime       = 0;
our $opt_verbose        = 1;
our $opt_delay          = -1;
our $opt_interval       = 0.1;
our $opt_change_driven  = 0;
our $opt_run_dupped     = 0;
our $opt_findex         = 0;
our $opt_keep_active    = 0;
our $opt_scriptdev;

my $opt_srcprog;
my $opt_runprog;
# our $opt_cmdline;
my @opt_args;
my $current_pid;
my $run_count           = 0;
my @keyq;
my @actq;
my $last_modified;
my $hwnd;
my $hidef;

my %extensions = (
    '.pl'   => 'perl',
    '.p'    => 'perl',
    '.py'   => 'python',
    '.pyc'  => 'python',
    '.rb'   => 'ruby',
);

sub boot {

    Win32::API->Import('user32', 'HWND GetTopWindow(HWND hWnd)');
    Win32::API->Import('user32', 'HWND GetForegroundWindow()');
    Win32::API->Import('user32', 'BOOL SetForegroundWindow(HWND hWnd)');
    Win32::API->Import('user32', 'HWND GetActiveWindow()');
    Win32::API->Import('user32', 'HWND SetActiveWindow(HWND hWnd)');
    Win32::API->Import('user32', 'HWND GetFocus()');
    Win32::API->Import('user32', 'HWND SetFocus(HWND hWnd)');
    Win32::API->Import('user32', 'BOOL ShowWindow(HWND hWnd, UINT nCmdShow)');
    Win32::API->Import('user32', 'int GetWindowTextLength(HWND hWnd)');
    Win32::API->Import('user32', 'GetWindowText', 'NPN', 'N'); #(HWND hWnd, LPTSTR lpString, int nMaxCount)');

    for my $i (0..$#ARGV) {
        if ($ARGV[$i] eq '--') {
            @opt_args = splice(@ARGV, $i + 1);
            pop @ARGV;
        }
    }
    GetOptions('quiet|q'    => sub { $opt_verbose-- },
               'verbose|v'  => sub { $opt_verbose++ },
               'version'    => sub { version; exit },
               'help|h'     => sub { help; exit },
               'delay|d=n',
               'change-driven|c',
               'run-dupped|d',
               'findex|f=n',
               'keep-active',
               'scriptdev|s',
               );
    # $opt_run_dupped = 1 if $opt_change_driven;

    if (@ARGV) {
        push @opt_args, @ARGV;
        @ARGV = ();
    }

    if ($opt_scriptdev) {
        my ($file, $ext) = path_splitext $opt_args[0];
        my $p = $extensions{$ext};
        die "Script with extension $ext isn't support" unless defined $p;
        info2 "using interpreter $p for script$ext";
        unshift @opt_args, $p;
        $opt_findex++;
        $opt_change_driven = 1;
        $opt_keep_active = 1;
    }

    $opt_srcprog = $opt_args[$opt_findex] unless $opt_srcprog;
    die "No command specified. " unless $opt_srcprog;

    $opt_runprog = $opt_srcprog;
    if ($opt_run_dupped) {
        my ($dir, $base) = path_split $opt_srcprog;
        my ($file, $ext) = path_splitext $base;
        $base = $file . '.copied' . $ext;
        $opt_runprog = path_join($dir, $base);
        $opt_args[$opt_findex] = $opt_runprog;
    }
    # $opt_cmdline = "\"$opt_runprog\" " . join(' ', @opt_args);

    info2 "delay         = $opt_delay";
    info2 "change-driven = $opt_change_driven";
    info2 "src-program   = $opt_srcprog";
    info2 "run-program   = $opt_runprog";
    info2 "run-args      = ".join(',', @opt_args);
    # info2 "run-cmdline   = $opt_cmdline";

    # die "File $opt_srcprog isn't executable" unless -X $opt_srcprog;

    main;
}

sub info {
    return if $opt_verbose < 1;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub info2 {
    return if $opt_verbose < 2;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub version {
    my %id = parse_id('$Id: loop2,v 1.7 2007-07-05 12:25:34 lenik Exp $');
    print "[$opt_verbtitle] Repeat running command \n";
    print "Written by Lenik,  Version $id{rev},  Last updated at $id{date}\n";
}

sub help {
    version;
    print <<"EOM";

Syntax:
        $0 <options> [--] command arguments...

Options:
        --delay=<seconds> (d, repeat interval)
        --change-driven (c, restart the program if changes)
        --run-dupped (d, run dupped program to enable write-access)
        --keep-active (keep active window always active)
        --findex=<integer> (f, program-file index in arguments, default 0)
        --scriptdev (s, auto detect file type, also set -c --keep-active)
        --quiet (q)
        --verbose (v, repeat twice give you more verbose info)
        --version
        --help (h)
EOM
}

exit boot;


sub main {
    while (1) {
        $last_modified = -M $opt_srcprog;

        $current_pid = run;
        info2 "still running: pid = $current_pid" if $current_pid;

        if ($opt_delay) {
            fwait $opt_delay;
        }
        if ($opt_change_driven) {
            info2 "waiting for changes of $opt_srcprog";
            while (-M $opt_srcprog == $last_modified) {
                # not-modified
                fwait $opt_interval;
                do_actq;
            }
            info2 "changement detected: $opt_srcprog";
            push @actq, 'kill';
        }
        do_actq;
    }
}

sub fwait {
    my $interval = shift;
    my $k = ReadKey $interval;
    if ($k) {
        # info2 'pressed: '.ord($k);
        quit if $k eq 'q';
        push(@keyq, $k);
    }
    do_keyq;
}

sub do_keyq {
    while (my $k = shift @keyq) {
        if ($k eq 't') {
            push @actq, 'touch-ps';
        } elsif ($k eq 'T') {
            push @actq, 'touch';
        } elsif ($k eq 'h') {
            push @actq, 'hide';
        } elsif ($k eq 's') {
            push @actq, 'show';
        } else {
            info "ignored keypress: $k";
        }
    }
}

sub do_actq {
    while (my $act = shift @actq) {
        if ($act eq 'touch-ps') {
            info "do pseudo-touch $opt_srcprog";
            undef $last_modified;
        } elsif ($act eq 'touch') {
            info "do touch $opt_srcprog";
            utime undef, undef, $opt_srcprog;
        } elsif ($act eq 'kill') {
            info "do kill $current_pid";
            killpid $current_pid;
            undef $current_pid;
        } elsif ($act eq 'hide') {
            # tray-icon...
            # Currently, delete $TEMP/HIDE.$hwnd to show the window.
            my $hide_info = `wm -v -hide`;
            my ($h) = $hide_info =~ /mlist: (\d+)/;
            if ($h) {
                $hwnd = $h;
                $hidef = temp_path('HIDE.'.$hwnd);
                writefile $hidef, '1';
                info "this window($hwnd) is hidden, please remove $hidef to show it again";
            } else {
                info "error when hiding the window";
                info2 "wm output: \n$hide_info";
            }
        } elsif ($act eq 'show') {
            # show self,
            # system 'wm -show';
            unlink $hidef if -f $hidef;
        } else {
            info "unknown action: $act";
        }
    }
    # check if restore the hidden windows
    if (defined $hidef) {
        if (! -f $hidef) {
            info2 "file-removal detected: $hidef";
            undef $hidef;
            info2 "show window: $hwnd";
            my $show_info = `wm -v -show -h $hwnd`;
        }
    }
}

sub run {
    my $win;
    if ($opt_keep_active) {
        $win = GetForegroundWindow();
        info2 "current window = $win: " . get_text($win);
    }

    if ($opt_run_dupped) {
        info2 "dup: $opt_srcprog -> $opt_runprog";
        cp $opt_srcprog, $opt_runprog
            or die("Error copy file $opt_srcprog to $opt_runprog: $!");
    }
    $run_count++;

    my $pid;

    if ($opt_change_driven) {
        # return pid[31..8] core?[7] signal[6..0]
        my $pid_file = temp_path('pid_'.int(rand 10000));
        info2 "enable pid-file: $pid_file";
        $ENV{'pid_file'} = $pid_file;

        info "spawn $opt_runprog ($run_count)";
        my $ret = system('spawn', @opt_args);
        die "failed to spawn: signal ".($ret & 127) if $ret & 127;

        # return $ret >> 8;
        die "pid-file $pid_file is expected to be created"
            unless -e $pid_file;
        $pid = readfile($pid_file);
        unlink $pid_file;
        chomp $pid;
    } else {
        # return exit-code
        info "exec $opt_runprog ($run_count)";
        system @opt_args;
    }

    if($opt_keep_active) {
        sleep 2 if $opt_change_driven;
        info2 "focus back to window: $win";
        set_focus $win;
    }

    return $pid;
}

sub get_text {
    my $hwnd = shift;
    my $len = GetWindowTextLength($hwnd) + 10;
    my $buf = ' ' x $len;
    $len = GetWindowText($hwnd, $buf, $len);
    return substr($buf, 0, $len);
}

# Don't work.
sub set_focus {
    my $hwnd = shift;
    #info2 "SetActiveWindow = ".
        SetActiveWindow($hwnd);
    #info2 "SetFocus = ".
        SetFocus($hwnd);
    #info2 "SetForegroundWindow = ".
        SetForegroundWindow($hwnd);
}

sub killpid {
    my $pid = shift;
    system 'kill '.$pid;
    #my $cnt = kill 'HUP' => $pid;
    #info2 "kill process $pid: $cnt";
}

sub quit {
    info "quitting";
    if ($opt_run_dupped) {
        info2 "remove dupped program: $opt_runprog";
        unlink $opt_runprog;
    }
    exit;
}
