#!/usr/bin/perl

=head1 NAME

dnac - DNA Compiler

=cut
use strict;
#@DNA::COPY
use vars qw(%RCSID);
use vars qw($LOGNAME $LOGLEVEL);
use cmt::codec;
use cmt::g;
use cmt::log(2);
    $LOGNAME    = 'dnac'; # $0 =~ /([^\/\\.]+)(?:\.\w+)*$/;
use cmt::time('cdatetime');
use cmt::vcs('parse_id');
#@DNA::COPY
    our %RCSID   = parse_id('$Id$');
use Crypt::DES;
use Crypt::CBC;
use Getopt::Long;
use Term::ReadKey;

sub _main; sub _version; sub _help;
sub encode;
sub encode_line;

#@DNA::PARTIAL G-MOD
    my @slice_graph = (
        ' ', '',
        '', '--',
        '', '---',
        '', '----',
        ' ', '----',
        '  ', '----',
        '   ', '---',
        '    ', '--',
        '     ', '',
        '     ', '',
        '    ', '--',
        '   ', '---',
        '  ', '----',
        ' ', '----',
        '', '----',
        '', '---',
        '', '--',
        ' ', '',
        );
    my $slice_block     = scalar(@slice_graph);
    my @slice_char      = qw/A T C G/;
    my @slice_char_x    = qw/T A G C/;
    my $current_slice   = 0;

    my $now = cdatetime;

    my $T_HDR = <<"EOM";

# The DNA is generated by DNA-Compiler 0.$RCSID{rev}
# Date $now

				 \$_
				=\$_;
				\$_='_
				<---->
				 '; use
				  strict
				   ;\$_='
				    G--C
				     AT
				     GC
				    T--A
				   ';use
				  cmt::g
				 ;  DNA
				<<DNA;
				<--->
				<-->
				 #
EOM

    my $T_END = "\nDNA\n\n  \n  ";
    my $T_SUB_HDR = "DNA\n";
    my $T_SUB_END = "    DNA<<DNA; \n";

#@DNA::PARTIAL G-BOOT

our $opt_indent = 4;
our $opt_protect;
our $opt_protect_scheme;
our $opt_cipher;

sub _boot {
    GetOptions('quiet|q'        => sub { $LOGLEVEL-- },
               'verbose|v'      => sub { $LOGLEVEL++ },
               'version'        => sub { _version; exit 0 },
               'help|h'         => sub { _help; exit 0 },
               'indent=n',
               'protect=s',
               );
    $opt_indent = "\t" x $opt_indent;

    if (defined $opt_protect and $opt_protect eq '') {
        my ($pass1, $pass2);
        ReadMode 'noecho';

        print STDERR "Enter passphrase: \n";
        $pass1 = ReadLine 0;
        chomp $pass1;

        print STDERR "Verify passphrase: \n";
        $pass2 = ReadLine 0;
        chomp $pass2;

        ReadMode 'normal';
        die "Unmatched." if ($pass1 ne $pass2);
        $opt_protect = $pass1;
    }

    if (defined $opt_protect) {
        $opt_protect_scheme = 'des';
        $opt_cipher = new Crypt::CBC($opt_protect, 'DES');
    }

    _main;
}

=head1 SYNOPSIS

B<dnac>
    S<[ B<-q> | B<--quiet> ]>
    S<[ B<-v> | B<--verbose> ]>
    S<[ B<-h> | B<--help> ]>
    S<[ B<--version> ]>
    S<[ B<--> ]>
    S<[ I<...the rest of arguments...> ]>

=head1 DNA Compiler

B<dnac> is a WHAT used for WHAT. It HOW-WORKS.

BACKGROUND-PROBLEM.

HOW-dnac-RESOLVES.

=head1 OPTIONS

=over 8

=item B<-m> | B<--my-option>

...

=item B<-q> | B<--quiet>

Repeat this option to suppress unimportant information to display.

=item B<-v> | B<--verbose>

Repeat this option to display more detailed information.

=item B<-h> | B<--help>

Display a breif help page and exit(0).

=item B<--version>

Display a short version information and exit(0).

=back

=head1 ENVIRONMENT

=over 8

=item TEMP, TMP

TEMP(or TMP, if $TEMP directory isn't existed) directory used to create
temporary files.

=back

=cut
sub _help {
    &_version;
    print "\nSyntax: \n    $0 [OPTION] [--] ...\n", <<'EOM';

Common options:
        --indent=NUM
        --protect=PASSWD    `dq' for DQ-codec (not impl.)
    -q, --quiet             repeat to get less info
    -v, --verbose           repeat to get more info
    -h, --help              show this help page
        --version           print the version info
EOM
}

exit (_boot or 0);

#@DNA::PARTIAL G-KER

sub _main {
    print $T_HDR;

    my $state = 'PARTIAL';

    if ($opt_protect_scheme) {
        encode_line("#\@DNA::PROTECT $opt_protect_scheme\n");
    }

    while (<>) {
        chomp;

        # do copy
        if ($state eq 'COPY') {
            print "$T_SUB_HDR$_\n$T_SUB_END";
            $state = 'PARTIAL';
            next;
        }

        # process instructions
        if (m/^\#\@DNA::(\w+)\s*(.*)$/) {
            my ($_cmd, $_args) = ($1, $2);
            if ($_cmd eq 'PARTIAL') {
                print "$opt_indent\# $_args\n";
                $state = 'PARTIAL';
            } elsif ($_cmd eq 'COPY') {
                # copy 1 line
                $state = 'COPY';
            }
        }

        # encrypt each line here
        if ($opt_cipher) {
            $_ = binhex($opt_cipher->encrypt(pack('n', length($_)) . $_));
        }

        # dna-encode
        encode_line("$_\n");
    }

    print $T_END;
}

=head1 DIAGNOSTICS

(No Information)

=cut
# (HELPER FUNCTIONS)

#@DNA::PARTIAL G-KER-X

sub encode {
    my $data = shift;
    my $datalen = length($data);
    my $mess = 0;

    my @ret;
    my $savearray = wantarray;

    for (my $i = 0; $i < $datalen; $i++) {
        my $i_chr = substr($data, $i, 1);
        my $i_ord = ord $i_chr;
        for (my $j = 0; $j < 4; $j++) {
            my $bit2 = (($i_ord >> 6) + $mess++) & 3;
                $i_ord <<= 2;
            my $line = $slice_graph[$current_slice]
                     . $slice_char[$bit2]
                     . $slice_graph[$current_slice + 1]
                     . $slice_char_x[$bit2]
                     . "\n";
            if ($savearray) {
                push @ret, $line;
            } else {
                print $line;
            }
            $current_slice = ($current_slice + 2) % $slice_block;
        }
    }
    return @ret;
}

sub encode_line {
    my $data = shift;
    # $state eq PARTIAL
    my @line = encode($data);
    my $lastline = $line[scalar(@line) - 1];
    my ($delimiter_pad, $delimiter_len) = $lastline =~ m/^(\s*).(-*)/;
    foreach (@line) {
        print "$opt_indent$_";
    }
    if ($delimiter_len) {
        print "$opt_indent$delimiter_pad<$delimiter_len>\n";
    } else {
        print "$opt_indent$delimiter_pad#\n";
    }
}

=head1 HACKING

(No Information)

=cut
# (MODULE FUNCTIONS)

=head1 HISTORY

=over

=item 0.x

The initial version.

=back

=cut
sub _version {
    print "[$LOGNAME] DNA Compiler \n";
    print "Written by Lenik,  Version 0.$RCSID{rev},  Last updated at $RCSID{date}\n";
}

=head1 SEE ALSO

The L<cmt/"Perl_simple_cli_program_template">

=head1 AUTHOR

Xima Lenik <name@mail.box>

=cut
