#!/usr/bin/perl

#@DNA::COPY
use vars qw/$idt/;
#@DNA::COPY
our $idt = '$Id: dnac,v 1.8 2007-09-12 17:12:41 lenik Exp $';

use strict;
use POSIX qw/strftime/;
use Getopt::Long;
use cmt::g;
use cmt::vcs;
use Term::ReadKey;


#@DNA::PARTIAL G-MOD

    my @slice_graph = (
        ' ', '',
        '', '--',
        '', '---',
        '', '----',
        ' ', '----',
        '  ', '----',
        '   ', '---',
        '    ', '--',
        '     ', '',
        '     ', '',
        '    ', '--',
        '   ', '---',
        '  ', '----',
        ' ', '----',
        '', '----',
        '', '---',
        '', '--',
        ' ', '',
        );
    my $slice_block = scalar(@slice_graph);
    my @slice_char = qw/A T C G/;
    my @slice_char_x = qw/T A G C/;
    my $current_slice = 0;

sub encode {
    my $data = shift;
    my $datalen = length($data);
    my $mess = 0;

    my @ret;
    my $savearray = wantarray;

    for (my $i = 0; $i < $datalen; $i++) {
        my $i_chr = substr($data, $i, 1);
        my $i_ord = ord $i_chr;
        for (my $j = 0; $j < 4; $j++) {
            my $bit2 = (($i_ord >> 6) + $mess++) & 3;
                $i_ord <<= 2;
            my $line = $slice_graph[$current_slice]
                     . $slice_char[$bit2]
                     . $slice_graph[$current_slice + 1]
                     . $slice_char_x[$bit2]
                     . "\n";
            if ($savearray) {
                push @ret, $line;
            } else {
                print $line;
            }
            $current_slice = ($current_slice + 2) % $slice_block;
        }
    }
    return @ret;
}


#@DNA::PARTIAL G-IN

    my %id = parse_id($idt);
    my $now = strftime "%Y-%m-%d %H:%M:%S", localtime;

    my $T_HDR = <<"EOM";

# The DNA is generated by DNA-Compiler $id{rev}
# Date $now

				 \$_
				=\$_;
				\$_='_
				<---->
				 '; use
				  strict
				   ;\$_='
				    G--C
				     AT
				     GC
				    T--A
				   ';use
				  cmt::g
				 ;  DNA
				<<DNA;
				<--->
				<-->
				 #
EOM

    my $T_END = <<'EOM';

DNA


EOM

    my $T_SUB_HDR = <<"EOM";
DNA
EOM
    my $T_SUB_END = <<"EOM";
    DNA<<DNA;
EOM


#@DNA::PARTIAL G-KER

    our $opt_indent = 4;
    our $opt_protect;
    our $opt_protect_scheme;
    our $opt_cipher;

    GetOptions(
        'indent=n',
        'protect=s',
        'help'      => sub { &help },
        );

    if ($opt_protect eq '?') {
        my ($pass1, $pass2);
        ReadMode 'noecho' ;

        print STDERR "Enter passphrase: \n";
        $pass1 = ReadLine 0;
        chomp $pass1;

        print STDERR "Verify passphrase: \n";
        $pass2 = ReadLine 0;
        chomp $pass2;

        ReadMode 'normal';
        die "Unmatched." if ($pass1 ne $pass2);
        $opt_protect = $pass1;
    }

    if (defined $opt_protect) {
        &init_protect;
        $opt_protect_scheme = 'des';
        $opt_cipher = new Crypt::CBC($opt_protect, 'DES');
    }


    print $T_HDR;


    my $indent = "\t"x$opt_indent;
    my $state = 'PARTIAL';

    if ($opt_protect_scheme) {
        encode_line("#\@DNA::PROTECT $opt_protect_scheme\n");
    }

    while (<>) {
        chomp;

        # do copy
        if ($state eq 'COPY') {
            print "$T_SUB_HDR$_\n$T_SUB_END";
            $state = 'PARTIAL';
            next;
        }

        # process instructions
        if (m/^\#\@DNA::(\w+)\s*(.*)$/) {
            my ($_cmd, $_args) = ($1, $2);
            if ($_cmd eq 'PARTIAL') {
                print "$indent\# $_args\n";
                $state = 'PARTIAL';
            } elsif ($_cmd eq 'COPY') {
                # copy 1 line
                $state = 'COPY';
            }
        }

        # encrypt each line here
        if ($opt_cipher) {
            $_ = binhex($opt_cipher->encrypt(pack('n', length($_)) . $_));
        }

        # dna-encode
        encode_line("$_\n");
    }

    print $T_END;


#@DNA::PARTIAL G-KER-X

sub encode_line {
    my $data = shift;
    # $state eq PARTIAL
    my @line = encode($data);
    my $lastline = $line[scalar(@line) - 1];
    my ($delimiter_pad, $delimiter_len) = $lastline =~ m/^(\s*).(-*)/;
    foreach (@line) {
        print "$indent$_";
    }
    if ($delimiter_len) {
        print "$indent$delimiter_pad<$delimiter_len>\n";
    } else {
        print "$indent$delimiter_pad#\n";
    }
}


sub init_protect {
    use cmt::codec;
    use Crypt::DES;
    use Crypt::CBC;
}



sub help {
    print <<"EOM";
DNA Compiler    By S.N.M.
Version 0.$id{rev}    Last Updated $id{date}

Syntax
    dnac
        --indent=<indents>
        --protect=<passphrase, ? for keyboard input, dq for DQ-codec>
        --help
EOM
    exit;
}
