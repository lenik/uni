#!/usr/bin/perl

use strict;
use Getopt::Long;
use IO::Socket;
use IO::Select;
use cmt::util;
use cmt::vcs;
use cmt::echohh;
use cmt::simpled;
use Data::Dumper;

sub main;
sub get_wan_address;
sub serv;
sub linkmain;
sub version;
sub help;
sub print_options;
sub info;
sub info2;
sub sendbuf_none;
sub sendbuf_text;

# if the specified port is same as DEFAULT_PORT,
# then the port will be binded if it hasn't been binded yet.
our $DEFAULT_PORT   = 51296;

our $PROTO_TCP      = getprotobyname("tcp");
our $PROTO_UDP      = getprotobyname("udp");

our $opt_host       = undef;
our $opt_port       = $DEFAULT_PORT;
our $opt_serv       = undef;        # running a simple serv at the port ?
our $opt_text       = 'kEEplInk';
our $opt_method     = 'text';       # \&sendbuf_text
our $opt_interval   = 3;            # 3 sec
our $opt_refresh    = 5;            # 5 sec
our $opt_logfile    = undef;
our $opt_verbose    = 0;
our $opt_verbtitle  = 'keeplink';

sub main {
    GetOptions(
        'echohh=s' => sub { my $s = $_[1]; echohh_addservice $s; },
        'help' => sub { &help, exit },
        'host|h=s',
        'interval=n',
        'method=s',
        'port=n',
        'refresh=n',
        'serv!',
        'text=s',
        'logfile:s',
        'verbose|v' => sub { $opt_verbose++ },
        'version' => sub { &version, exit },
        );

    if (defined $opt_logfile) {
        if ('' eq $opt_logfile) {
            my $tmp = $ENV{'TMP'} || $ENV{'TEMP'};
            $opt_logfile = $tmp . '/keeplink.log';
        }
        info "log to file: $opt_logfile";
        open(LOGFILE, ">>$opt_logfile")
            || die("can't open logfile");
        LOGFILE->autoflush(1);
        select(LOGFILE);
    }

    $opt_host = get_wan_address if not defined $opt_host;

    print_options if $opt_verbose;

    # eval to sub ptr.
    # TODO - sendbuf_?? isn't exist?
    $opt_method = eval('\&sendbuf_' . $opt_method);

    # start a default server
    $opt_serv = $opt_port == $DEFAULT_PORT
        unless defined $opt_serv;
    if ($opt_serv) {
        # start serv in a separate thread
        if (! fork) { # child process
            serv;
            exit;
        }
    }

    my $count = 0;
    while (1) {
        info "New link " . $count++;
        linkmain;
    }
}

sub get_wan_address {
    info "Get WAN Address of localhost";
    my $remote_addr = echohh_server('REMOTE_ADDR');
    info "WAN Address: $remote_addr";
    return $remote_addr;
}

sub serv {
    info "Initialize echod service at port $opt_port";
    my $serv = echod($opt_port);
    $serv->verbose($opt_verbose);
    return $serv->serv;
}

sub linkmain {
    # 1, connect host:port
    info "Connect to $opt_host:$opt_port";

    # TODO - more controls, UDP, etc.
    my $sock = new IO::Socket::INET(
        PeerAddr    => $opt_host,
        PeerPort    => $opt_port,
        Type        => SOCK_STREAM,
        Proto       => 'tcp'
        );
    if (! $sock) {
        info "Can't connect: $!";
        return 0;
    }
    $sock->autoflush(1);        # as "$| = 1" does.
    info "Connected.";

    my $set = new IO::Select;
    $set->add($sock);

    my $counter = 0;
    my $lastinfo = time;
    my $lastwrite = time - $opt_interval * 2;

    # 2, repeat send...

    my $selread = $set;
    my $selwrite = $set;
    my $selex = $set;

    while ($set->count) {
        $counter++;
        if (time - $lastinfo > $opt_refresh) {
            info2 "heartbeat $counter";
            $lastinfo = time;
        }

        # blocks until a handle is ready.
        # select(READ, WRITE, ERROR [, TIMEOUT])
        my @all = IO::Select->select($selread, $selwrite, $selex
                                     , $opt_interval); #
        my @hs;

        @hs = @all ? @{$all[0]} : ();
        for my $h (@hs) {
            my $input = <$h>;
            info2 "recv $input"
        }

        if (time - $lastwrite > $opt_interval) {
            if (defined $selwrite) {
                @hs = @all ? @{$all[1]} : ();
                for my $h (@hs) {
                    my $buf = &$opt_method;
                    print $sock $buf;
                    info2 "sent $buf";
                }
                $selwrite = undef;
                $lastwrite = time;
            } else {
                $selwrite = $set;
            }
        }

        @hs = @all ? @{$all[2]} : ();
        for my $h (@hs) {
            info "exception";
            $h->shutdown(2);
            $set->remove($h);
        }
    }

    return $counter;
}

sub version {
    my %id = parse_id('$Id: keeplink.pld,v 1.4 2006-10-20 10:18:10 lenik Exp $');
    print "[KEEPLINK] Keep network link by repeat sending\n";
    print "Written by Lenik,  Version $id{rev},  Last updated at $id{date}\n";
}

sub help {
    &version;
    print <<"EOM";

Syntax:
        keeplink <options>

Options:
        --host=<host-address> (h, default is wan-address)
        --port=<port> (p, default $DEFAULT_PORT)
        --serv or --noserv (s, running a simple service at the port)
        --text=<text message to send> (t, default "kEEplInk")
        --method=<send method> (m, default 'text')
        --interval=<number of seconds> (i, send interval, default 3 sec.)
        --echohh=<echohh-service url>
            (e, the service is used to get the wan-address of localhost)
        --logfile=<path> (l, default log to stdout)
        --verbose (v, repeat twice give you more verbose info)
        --refresh=<number of seconds> (r, refresh interval for verbose)
        --version
        --help

Send Methods:
        none        don't send anything
        text        send the option value of --text

EOM
}

sub print_options {
    print <<"EOM";
        Host        $opt_host
        Port        $opt_port
        Text        $opt_text
        Method      $opt_method
        Interval    $opt_interval
        Refresh     $opt_refresh
        Verbose     $opt_verbose
EOM
}

sub info {
    if ($opt_verbose >= 1) {
        my $msg = shift;
        my $date = datetime;
        print "$date [$opt_verbtitle] $msg\n";
    }
}

sub info2 {
    if ($opt_verbose >= 2) {
        my $msg = shift;
        print datetime." [$opt_verbtitle] $msg\n";
    }
}

sub sendbuf_none {
    my $none = undef;
    return $none;
}

sub sendbuf_text {
    return "$opt_text\n";
}

main;
