#!/usr/bin/perl

=head1 NAME

laxar - Lapiota import/export archiver

=cut
use strict;
use vars qw($LOGNAME $LOGLEVEL);
use cmt::fileproc('/[$%]/', 'batch_main');
use cmt::lang();
use cmt::log(3);
    $LOGNAME    = 'laxar'; # $0 =~ /([^\/\\.]+)(?:\.\w+)*$/;
use cmt::path('path_join');
use cmt::util('qsplit', 'readfile');
use cmt::vcs('parse_id');
    my %RCSID   = parse_id('$Id: .pl 776 2007-12-24 12:11:36Z lenik $');
use Digest::MD5 qw/md5 md5_hex md5_base64/;
use Digest::SHA1 qw/sha1 sha1_hex sha1_base64/;
use Getopt::Long;

sub _main; sub _version; sub _help;
sub parse_err;
sub do_archive;
sub output;

our %opt_COMOPT_tmpl;
our $opt_ignore_case;
our $opt_algorithm      = 'md5';
our $opt_sum;
our $opt_executable;
our $opt_out;
our $opt_stdout;
our $opt_extname        = '.lxar';

our $lxl_basenam;
our $lxl_baseval;
our @lxl_filelist;
our $lxl_algorithm;
our $lxl_sum;

sub _boot {
    GetOptions('quiet|q'        => sub { $LOGLEVEL-- },
               'verbose|v'      => sub { $LOGLEVEL++ },
               'version'        => sub { _version; exit 0 },
               'help|h'         => sub { _help; exit 0 },
               %COMOPT,         # bcdfikrtw
               'algorithm|a=s',
               'sum|s=s',
               'executable|e',
               'encoding=s',
               'out|o=s',
               );
    $opt_ignore_case            = $cmt::fileproc::opt_ignore_case;
    $opt_stdout                 = $cmt::fileproc::opt_stdout;
    $cmt::fileproc::LOGLEVEL    = $LOGLEVEL - 2;

    %opt_COMOPT_tmpl = cmt::fileproc::save_opts;

    die "executable is not supported, yet." if $opt_executable;

    _main;
}

=head1 SYNOPSIS

B<laxar>
    S<[ B<-q> | B<--quiet> ]>
    S<[ B<-v> | B<--verbose> ]>
    S<[ B<-h> | B<--help> ]>
    S<[ B<--version> ]>
    S<[ B<--> ]>
    S<[ I<...the rest of arguments...> ]>

=head1 Lapiota import/export archiver

B<laxar> is a WHAT used for WHAT. It HOW-WORKS.

BACKGROUND-PROBLEM.

HOW-laxar-RESOLVES.

=head1 OPTIONS

=over 8

=item B<-m> | B<--my-option>

...

=item B<-q> | B<--quiet>

Repeat this option to suppress unimportant information to display.

=item B<-v> | B<--verbose>

Repeat this option to display more detailed information.

=item B<-h> | B<--help>

Display a breif help page and exit(0).

=item B<--version>

Display a short version information and exit(0).

=back

=head1 ENVIRONMENT

=over 8

=item TEMP, TMP

TEMP(or TMP, if $TEMP directory isn't existed) directory used to create
temporary files.

=back

=cut
sub _help {
    &_version;
    print "\nSyntax: \n    $0 [OPTION] [--] [FILE.lxl]\n", <<"EOM";

Common options:
$COMOPT    -a, --algorithm=ALG     digest algorithm, default md5
    -e, --executable        make self-extractable archive
        --encoding=ENC      encoding of the .lxl file, default utf-8
    -o, --out=FILE          output to FILE, default FILE.lxar
    -q, --quiet             repeat to get less info
    -v, --verbose           repeat to get more info
    -h, --help              show this help page
        --version           print the version info

lxl-section options (override to the common options):
$COMOPT    -a, --algorithm=ALG     digest algorithm, default md5
    -s, --sum=CHECKSUM      specify or calculate from the given files

EOM
}

exit (_boot or 0);

sub _main {
    my $paramidx = 0;
    my $lxl_section = 0;
    while (<>) {
        s/^\s+//;
        next if /^#/;
        s/\s+$//s;
        if ($_ eq '') {
            $paramidx = 0;
            next;
        }
        if ($paramidx == 0) {
            my ($key, $val) = split(/\s*=\s*/, $_, 2);
            if ($key eq '') { parse_err "invalid param: base is empty" }
            $lxl_basenam = $key;
            $lxl_baseval = $val;
            $paramidx++;
            next;
        }
        my @ARGV_bak = @ARGV;
        @ARGV = qsplit(qr/\s+/, $_);
        cmt::fileproc::load_opts %opt_COMOPT_tmpl;
        $lxl_algorithm = $opt_algorithm;
        $lxl_sum       = undef;
        GetOptions(%COMOPT,
                   'algorithm|a=s'  => \$lxl_algorithm,
                   'sum|s=s'        => \$lxl_sum,
                   );
        my $lxl_file = join(' ', @ARGV);
        my $start = path_join($lxl_baseval, $lxl_file);
        ++$lxl_section;
        _log2 "prep $start";
        @lxl_filelist = ();
        batch_main sub { local *__ANON__ = "<lxl-section-$lxl_section>";
            my $path = shift;
            my $based = substr($path, length($lxl_baseval));
               $based =~ s/^[\\\/]//;
            my $dpath = $lxl_basenam.'::'.$based;
            _sig2 'scan', $dpath;
            push @lxl_filelist, $based;
            0
        }, $start;
        _sig2 'prepdone';
        do_archive;
        @ARGV = @ARGV_bak;
        $paramidx++;
    }

}

=head1 DIAGNOSTICS

(No Information)

=cut
# (HELPER FUNCTIONS)

=head1 HACKING

(No Information)

=cut
# (MODULE FUNCTIONS)
sub do_archive {
    _log1 $lxl_basenam.'::';
    for (@lxl_filelist) {
        my $path = path_join($lxl_baseval, $_);
        my $size = -s $path;
        my $sum  = $lxl_sum;
           $sum = sum($path, $lxl_algorithm) unless defined $sum;
        output "$lxl_basenam = $lxl_baseval\n";
        output "-a $lxl_algorithm -s $sum -- $_\n";
        output "$size\n";
        _log1 '  '.$_ . " ($size bytes)";
        open(FH, '<', $path)
            or die "can't read from $path: $!";
        binmode FH;
        output $_ while <FH>;
        close FH;
        output "\n";
    }
}

sub sum {
    my ($path, $alg) = @_;
    my $algf = main->can($alg.'_hex') or die "unsupported algorithm: $alg";
    my $dat = readfile($path);
    $algf->($dat)
}

sub output {
    print for @_;
}

=head1 HISTORY

=over

=item 0.x

The initial version.

=back

=cut
sub _version {
    print "[$LOGNAME] Lapiota import/export archiver \n";
    print "Written by Lenik,  Version 0.$RCSID{rev},  Last updated at $RCSID{date}\n";
}

=head1 SEE ALSO

The L<cmt/"Perl_simple_cli_program_template">

=head1 AUTHOR

Xima Lenik <name@mail.box>

=cut
