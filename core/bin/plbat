#!/usr/bin/perl

=head1 NAME

plbat - perl/bat wrapper

=cut
use strict;
use vars qw($LOGNAME $LOGLEVEL);
    $LOGNAME    = 'plbat'; # $0 =~ /([^\/\\.]+)(?:\.\w+)*$/;
use cmt::log(2);
use cmt::path;
use cmt::pp('ppvar');
use cmt::util('writefile');
use cmt::vcs('parse_id');
    my %RCSID   = parse_id('$Id: .pl,v 1.16 2007-09-29 11:31:33 lenik Exp $');
use Getopt::Long;

sub _main; sub _version; sub _help;

our $opt_output;
our $opt_console;
our $opt_make;
our $opt_prefix;

my $tmpl;

sub _boot {
    GetOptions('quiet|q'        => sub { $LOGLEVEL-- },
               'verbose|v'      => sub { $LOGLEVEL++ },
               'version'        => sub { _version; exit 0 },
               'help|h'         => sub { _help; exit 0 },
               'output|o=s',
               'console|c',
               'make|m',
               'prefix|p=s',
               );

    if ($opt_make) {
        while (<>) {
            next if /^\s*$/;
            s/\s*$//;
            if (/^!\s+([^=]+)=(.*)$/) {
                my ($opt, $val) = ($1, $2);
                _log1 "set $opt to $val";
                my $ref = eval '\$opt_'.$opt;
                die "invalid option $opt: $@" if $@;
                $$ref = $2;
                next
            }
            my ($bat, $pl) = split(':', $_, 2);
            unless (defined $pl) {
                my ($bat_name, $bat_ext) = path_splitext $bat;
                $pl = $bat_name . '';
            }
            $opt_output = $opt_prefix.$bat;
            _log1 "wrap $opt_output -> $pl";
            _main $pl;
        }
    } else {
        die "no perl-file specified" unless @ARGV;
        _log1 "wrap $ARGV[0]";
        _main $ARGV[0];
    }
}

=head1 SYNOPSIS

B<plbat>
    S<[ B<-q> | B<--quiet> ]>
    S<[ B<-v> | B<--verbose> ]>
    S<[ B<-h> | B<--help> ]>
    S<[ B<--version> ]>
    S<[ B<--> ]>
    S<[ I<...the rest of arguments...> ]>

=head1 DESCRIPTION

B<plbat> is a WHAT used for WHAT. It HOW-WORKS.

BACKGROUND-PROBLEM.

HOW-plbat-RESOLVES.

=head1 OPTIONS

=over 8

=item B<-m> | B<--my-option>

...

=item B<-q> | B<--quiet>

Repeat this option to suppress unimportant information to display.

=item B<-v> | B<--verbose>

Repeat this option to display more detailed information.

=item B<-h> | B<--help>

Display a breif help page and exit(0).

=item B<--version>

Display a short version information and exit(0).

=back

=head1 ENVIRONMENT

=over 8

=item TEMP, TMP

TEMP(or TMP, if $TEMP directory isn't existed) directory used to create
temporary files.

=back

=cut
sub _help {
    &_version;
    print "\nSyntax: \n";
    print "    $0 [OPTION] [--] PERL-FILE.pl\n";
    print "    $0 [OPTION] -m [--] [LIST-FILES]\n", <<'EOM';

Common options:
    -c, --console           output to stdout
    -o, --output=FILE       specify output file name, default perl-file.bat
    -m, --make              read file entries from STDIN or the given LIST-FILE
    -q, --quiet             repeat to get less info
    -v, --verbose           repeat to get more info
    -h, --help              show this help page
        --version           print the version info
EOM
}

exit (_boot or 0);

sub _main {
    my $perl_file    = shift;
    my $bat_file     = $opt_output;

    my $target_name  = '%~n0';      # the same name as perl-file
    my ($dir, $base) = path_split $perl_file;
    my ($file, $ext) = path_splitext $base;
    if (defined $bat_file) {
        my ($odir, $obase) = path_split $bat_file;
        my ($ofile, $oext) = path_splitext $obase;
        if ($ofile ne $file) {
            $target_name = $file;
        }
    } else {
        $bat_file = path_join($dir, $opt_prefix.$file.".bat");
    }

    my %vars = (
        NAME        => $target_name,
        GENERATOR   => "plbat $RCSID{rev}",
        );

    $tmpl = join('', <DATA>) unless defined $tmpl;

    my $cnt  = ppvar %vars, $tmpl;
    if ($opt_console) {
        print $cnt;
    } else {
        writefile $bat_file, $cnt;
    }
}

=head1 DIAGNOSTICS

(No Information)

=cut
# (HELPER FUNCTIONS)

=head1 HACKING

(No Information)

=cut
# (MODULE FUNCTIONS)

=head1 HISTORY

=over

=item 0.x

The initial version.

=back

=cut
sub _version {
    print "[$LOGNAME] perl/bat wrapper \n";
    print "Written by Lenik,  Version 0.$RCSID{rev},  Last updated at $RCSID{date}\n";
}

=head1 SEE ALSO

The L<cmt/"perl/bat wrapper">

=head1 AUTHOR

Xima Lenik <name@mail.box>

=cut

__DATA__
@echo off

    rem Generated by $GENERATOR

:check_os
    if "%OS%"=="" goto check_cmd
    if "%OS%"=="Windows_NT" goto check_cmd
    echo The operating system isn't supported: %OS%
    exit /b 1

:check_cmd
    verify other 2>nul
    setlocal enableextensions
    if not errorlevel 1 goto boot
    echo The cmd extensions isn't supported.
    echo Maybe your windows version is too old.
    exit /b 1

:check_more

:boot
    setlocal
    set _nam=$NAME
    set _ext=
    set PERLFLAGS=-w -Mcmt::mess

:find_target
    for %%x in ("" .pl .p .pc .pld) do (
        set _ext=%%~x
        if exist "%_nam%%%~x" (
            set _dir=
            goto find_shell
        )
        if exist "../%_nam%%%~x" (
            set _dir=../
            goto find_shell
        )
        for %%i in ("%_nam%%%~x") do (
            set _dir=%%~dp$PATH:i
            if exist "!_dir!%%~i" goto find_shell
        )
    )
    echo Can't find the target program %_nam%.
    exit /b 1

:find_shell
    if "%_shell%"=="" (
        for %%a in (%CMDCMDLINE%) do (
            for %%c in (%%a) do (
                set _shell=%%~nc
                goto start_mode
            )
        )
    )

:start_mode
    set _args=%*
    set _look=3
:next_arg
    if %_look% leq 3 goto bycmd
    if "%~1"=="" goto bycmd
    if "%~1"=="-v" goto start
    set _1=%~1
    if "%_1:~0,6%"=="--verb" goto start
    shift
    set /a _look = _look - 1
    goto next_arg

:bycmd
    if "%_shell%"=="cmdw" goto startw
    if "%_shell%"=="CMDW" goto startw
    goto start

:start
    if "%PERL%"=="" set PERL=perl
    "%PERL%" %PERLFLAGS% "%_dir%%_nam%%_ext%" %_args%
    goto end

:startw
    if "%PERLW%"=="" set PERLW=perlw
    "%PERLW%" %PERLFLAGS% "%_dir%%_nam%%_ext%" %_args%
    goto end

:end
