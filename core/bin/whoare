#!/usr/bin/perl
# $Id: whoare,v 1.9 2007-06-25 12:58:14 lenik Exp $

use strict;
use Socket;
use FileHandle;
use Getopt::Long;
use Time::HiRes qw/usleep/;
#use Thread;
use File::Basename;
use Data::Dumper;

sub _Verbose;

$| = 1;

our %tld_whois = (
    'com'       => 'whois.internic.com',
    'net'       => 'whois.internic.com',
    'org'       => 'whois.internic.com',
    'edu'       => 'whois.internic.com',
    'cn'        => 'whois.cnnic.net.cn',
    'biz'       => 'whois.biz',         #'whois.neulevel.biz',
    'bz'        => 'mhpwhois1.verisign-grs.net',
    'to'        => 'monarch.tonic.to',
    'gs'        => 'whois.adamsnames.tc',
    'ms'        => 'whois.adamsnames.tc',
    'tc'        => 'whois.adamsnames.tc',
    'tf'        => 'whois.adamsnames.tc',
    'vg'        => 'whois.adamsnames.tc',
    'aero'      => 'whois.aero',
    'info'      => 'whois.afilias.net',
    'am'        => 'whois.amnic.net',
    'au'        => 'whois.aunic.net',   # whois.apnic.net',
    'com.au'    => 'whois.ausregistry.net.au',
    'si'        => 'whois.arnes.si',
    'eu.lv'     => 'whois.biz',
    'cd'        => 'whois.cd',
    'br.com'    => 'whois.centralnic.com',
    'cn.com'    => 'whois.centralnic.com',
    'eu.com'    => 'whois.centralnic.com',
    'hu.com'    => 'whois.centralnic.com',
    'no.com'    => 'whois.centralnic.com',
    'qc.com'    => 'whois.centralnic.com',
    'sa.com'    => 'whois.centralnic.com',
    'se.com'    => 'whois.centralnic.com',
    'se.net'    => 'whois.centralnic.com',
    'us.com'    => 'whois.centralnic.com',
    'uy.com'    => 'whois.centralnic.com',
    'za.com'    => 'whois.centralnic.com',
    'uk.com'    => 'whois.centralnic.com',
    'uk.net'    => 'whois.centralnic.com',
    'gb.com'    => 'whois.centralnic.com',
    'gb.net'    => 'whois.centralnic.com',
    'gg.je'     => 'whois.channelisles.net',
    'ca'        => 'whois.cira.ca',
    'ug'        => 'whois.co.ug',
    'za'        => 'whois.co.za',
    'de'        => 'whois.denic.de',
    'dk'        => 'whois.dk-hostmaster.dk',
    'be'        => 'whois.dns.be',
    'lu'        => 'whois.dns.lu',
    'pl'        => 'whois.dns.pl',
    'nl'        => 'whois.domain-registry.nl',
    'kz'        => 'whois.domain.kz',
    'ie'        => 'whois.domainregistry.ie',
    'nz'        => 'whois.domainz.net.nz',
    'tk'        => 'whois.dot.tk',
    'gov'       => 'whois.dotgov.gov',
    'edu'       => 'whois.educause.edu',
    'ee'        => 'whois.eenet.ee',
    'hk'        => 'whois.hkirc.net',
    'int'       => 'whois.iana.org',
    'in'        => 'whois.iisc.ernet.in',
    'mil'       => 'whois.internic.net',
    'pro'       => 'whois.internic.net',
    'is'        => 'whois.isnic.is',
    'il'        => 'whois.isoc.org.il',
    'ke'        => 'whois.kenic.or.ke',
    'ec'        => 'whois.lac.net',
    'my'        => 'whois.mynic.net.my',
    'museum'    => 'whois.meseum',
    'ua'        => 'whois.net.ua',
    'jp'        => 'whois.nic.ad.jp',
    'org'       => 'whois.pir.org',
    'tw'        => 'whois.twnic.net.tw',
    'tv'        => 'whois.www.tv',
    );

our $proto_tcp = getprotobyname("tcp");

our $logfile = 'whois_logs.txt';


our $fuzzy_tbl = "abcdefghijklmnopqrstuvwxyz0123456789-";
our @fuzzy_set = split('', $fuzzy_tbl);
our $fuzzy_len = scalar(@fuzzy_set);
our @dict;

our $opt_verbose;
our $opt_test;
our $opt_mt = 1;
our $opt_maxt = 10;
our $opt_numbers;
our @opt_tla;

our @def_tla = qw/
        .com
        .net
        .org
        .info
        .cn
        .com.cn
    /;
        # .edu
        # .biz
        # .net.cn
        # .org.cn

our $ignore_first = 0;

# pid -> { starttime }
our %threads;

sub whois {
    my $svr = shift;
    my ($tld) = $svr =~ m/\.([^\.]+)$/;
    my $server = $tld_whois{$tld} || "whois.nic.$tld";

    die "WHOIS server undefined for TLD: $tld" if ! $server;
    my $iaddr = inet_aton($server);
        die "Server $server not found: $!" if !$iaddr;

    my $paddr = sockaddr_in(43, $iaddr);
    my $proto = $proto_tcp;
    my $info = {};
    local $_;

    socket(SOCK, PF_INET, SOCK_STREAM, $proto)
        or die "Can't create socket: $!";

    # svr|...
    print "$svr" unless $opt_mt;

    my $connected = 0;
    my $failcount = 0;
    while (not $connected) {
        $connected = connect(SOCK, $paddr);
        if (not $connected) {
            $failcount++;
            die "Connect failure: $!" if $failcount > 10;
            print STDERR "Connect failed: $!, Retry $failcount\n";
        }
    }

    # _Verbose "<send $svr";
    send(SOCK, "$svr\n", 0);
    # _Verbose " send>";

    # svr|...
    print "|" unless $opt_mt;

    while (<SOCK>) {
        s/\r|\n//;
        # _Verbose "<recv $_ />";
        if (m/^\s*Domain Name:\s*(.*)$/i) {
            $info->{domain} = $1;
        } elsif (m/^\s*Registrar:\s*(.*)$/i) {
            $info->{reg} = $1 if (! $info->{reg});
        } elsif (m/^\s*Registrant Name:\s*(.*)$/i) {
            $info->{reg} = $1 if (! $info->{reg});
        } elsif (m/^\s*Registrant Organization:\s*(.*)$/i) {
            $info->{reg} = $1 if (! $info->{reg});
        } elsif (m/^\s*Name Server:\s*(.*)$/i) {
            $info->{dns0} = $1 if (! $info->{dns0});
        } elsif (m/Registration Date:\s*(.*)$/i) {
            $info->{create} = $1;
        } elsif (m/Expiration Date:\s*(.*)$/i) {
            $info->{expire} = $1;
        } elsif (m/^No match(ing)?\b/i or m/^Not found\b/i) {
            $info = {};
            $info->{domain} = '***Available***';
            last;
        } elsif (m/^>>> /) {
            last;
        }
    }

    if (! $info->{domain}) {
        $info->{domain} = 'UNKNOWN';
    }

    close SOCK;

    return $info;
}


sub process {
    my $name = shift;

    if ($opt_test) {
        print "[test] $name\n";
        return;
    }

    my $wi;

    #my $errmax = 5;
    #my $whois_done = 0;
    #my $wref = \$whois_done;
    #while ($errmax > 0 and not $whois_done) {
    #    my $pid_whois = fork();

    #    if ($pid_whois) {
    #        my $timeout = 1000;
    #        while ($timeout > 0) {
    #            last if ($whois_done);
    #            $timeout--;
    #            print $whois_done;
    #            usleep 1000;
    #        }
    #        if (not $whois_done) {
    #            print "*KILL*";
    #            kill 'KILL', $pid_whois;
    #        }
    #    } else {
    #        print ">>";
            $wi = whois($name);
    #        print "<<";
    #        $$wref = 1;
    #        usleep 100000;
    #        exit;
    #    }
    #}

    #if (not $whois_done) {
    #    die "Whois-failure: retried too much\n";
    #}

    my $line =
        "$wi->{domain}|$wi->{reg}|$wi->{dns0}|$wi->{create}|$wi->{expire}\n";

    print "$name|" if $opt_mt;
    print $line;

    my $logs = new FileHandle(">>$logfile");
    $logs->write("$name|$line");
    $logs->close();
}


sub before_than {
    my ($a, $b) = @_;
    for (my $i = 0; $i < length($b); $i++) {
        my $ai = index($fuzzy_tbl, substr($a, $i, 1));
        my $bi = index($fuzzy_tbl, substr($b, $i, 1));

        return 1 if $ai >= 0 and $ai < $bi;
    }
    return 0;
}

sub after_than {
    my ($a, $b) = @_;
    for (my $i = 0; $i < length($b); $i++) {
        my $ai = index($fuzzy_tbl, substr($a, $i, 1));
        my $bi = index($fuzzy_tbl, substr($b, $i, 1));

        return 1 if $ai >= 0 and $ai > $bi;
    }
    return 0;
}


sub process_gen {
    my $gen = shift;
    for (@opt_tla) {
        process_any("$gen$_");
    }
}

sub process_any {
    my ($name, $st) = @_;
    $name = lc $name;
    return if ($name =~ m/^-/ or $name =~ m/-\./);

    if ($name =~ m/^(.*)\.\*$/) {
        process_gen($1);
        return;
    }
    if (index($name, '.') < 0) {
        process_gen($name);
        return;
    }

    # iterate alphabet
    if ($name =~ m/\?/) {
        my $xpos = $-[0];
        my $n2 = $name;
        my $i = 0;
        for (; $i < $fuzzy_len; $i++) {
            substr($n2, $xpos, 1) = $fuzzy_set[$i];
            if ($st) {
                next if before_than($n2, $st);
                undef $st if after_than($n2, $st);
            }
            process_any($n2, $st);
        }
        return;
    }

    # iterate word-list
    if ($name =~ m/\@/) {
        my $xpos = $-[0];
        my $i = 0;
        if ($st) {
            my $j = 0;
            for my $j (@dict) {
                last if ($st eq $j);
                $i++;
            }
            $ignore_first = 1;
        }
        for (; $i < scalar(@dict); $i++) {
            my $n2 = $name;
            substr($n2, $xpos, 1) = $dict[$i];
            process_any($n2, $st);
        }
        return;
    }

    if ($ignore_first) {
        $ignore_first = 0;
        return;
    }

    if ($opt_mt) {
        my $active_threads = 1 * scalar(%threads);
        if ($active_threads < $opt_maxt) {
            my $pid = fork;
            if ($pid) {
                $threads{$pid} = [ time() ];
            } else {
                _Verbose "[thread $$] start\n";
                process($name);
                exit;
            }
        } else {
            my $kill_timeouts = 1;
            if ($kill_timeouts) {
                for (keys %threads) {
                    my $pid = $_;
                    my @info = @{$threads{$pid}};
                    my $start = $info[0];
                    my $dur = time() - $start;
                    if ($dur > 10) {
                        _Verbose "[thread $pid timeout($dur)]\n";
                        kill $pid;
                        delete $threads{$pid};
                    }
                }
            }
            my $pid = wait;
            _Verbose "[thread $pid] end\n";
            delete $threads{$pid};
        }
    } else {
        process($name);
    }
}

sub process_arg {
    my $arg = shift;

    my ($pat, $start) = $arg =~ m/^([^\/]*)(\/.*)?/;
    $start = substr($start, 1) if $start;

    # set log-file and start-number for resuming
    if ($pat =~ m/\?/) {
        $logfile = "whois_$pat.txt";
        $logfile =~ s/\?/\%/g;

        if (! $start) {
            if (-f $logfile) {
                my $last = `tail -1 $logfile`;
                ($start) = $last =~ m/^(.*?)(?=\|)/;
            }
        }
    }
    if ($pat =~ m/\@/) {
        $logfile = "whois_$pat.txt";
        $logfile =~ s/\@/\$/g;

        if (! $start) {
            if (-f $logfile) {
                my ($sl, $sr) = map { length($_) }
                        $logfile =~ m/^whois_(.*)\$(.*)\.txt$/;
                my $last = `tail -1 $logfile`;
                ($start) = $last =~ m/^(.*?)(?=\|)/;
                $start = substr($start, $sl, length($start) - $sl - $sr);
            }
        }
    }

    $ignore_first = 1 if $start;
    process_any($pat, $start);
}

sub importwords {
    my $fn = shift;
    print "Word file: $fn\n";

    open LIST, "<$fn";
    my @words = <LIST>;
    push @dict, map { chomp; $_ } @words;
    close LIST;
}

my $options = GetOptions(
                         'verbose' => \$opt_verbose,
                         'test' => \$opt_test,
                         'multi-threads|mt'  => sub { $opt_mt = 1 },
                         'single-threads|st' => sub { $opt_mt = 0 },
                         'max-threads=n' => \$opt_maxt,
                         'numbers|n' => \$opt_numbers,
                         'tla|a=s' =>
                                sub {
                                    my ($opt, $ext) = @_;
                                    foreach (split(/[,:; ]/, $ext)) {
                                        $_ = '.' . $_ if ($_ !~ m/^\./);
                                        # print "[$_]\n";
                                        push @opt_tla, $_;
                                    }
                                },
                         'words-list|w:s' =>
                                sub {
                                    my ($opt, $fn) = @_;
                                    $fn = dirname($0) . '/words.txt' unless $fn;
                                    importwords($fn);
                                },
                         'help' => sub { &help; },
                         );

    if ($opt_numbers) {
        $fuzzy_tbl = "0123456789";
        @fuzzy_set = split('', $fuzzy_tbl);
        $fuzzy_len = scalar(@fuzzy_set);
    }

    if (scalar(@opt_tla) == 0) {
        @opt_tla = @def_tla;
    }

_Verbose $opt_mt == 1
    ? "Multithreads Mode($opt_maxt)\n"
    : "Singlethread Mode\n";

for (@ARGV) {
    process_arg $_;
}


sub _Verbose {
    return if (! $opt_verbose);
    print join('', @_);
}

sub help {
    print <<"EOM";
[WHOARE] Multi-domains Whois Query

Syntax:
    whoare
        --help (h)
        --verbose (v)
        --test (t)
        --single-threads (st)
        --multi-threads (mt)
        --max-threads=<number> (max)
        --numbers (n)
        --tla <TLA-list> (a)
        --words-list=<filename> (w, e.g. -w=t\0\words.txt)
EOM
    exit;
}
