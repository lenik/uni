#!perl -w

use strict;
use Getopt::Long;
use DirHandle;
use File::Copy;
use cmt::vcs;
use cmt::path;
use cmt::winuser;
use cmt::util;


our $nfs_appname = 'NFS Version 2';
our %nfs_id = parse_id('$Id: nfs,v 1.23 2007-04-27 13:31:59 lenik Exp $');

our %nfs_filetype = (
    ''      => 'ue "%s"',                   # default

    'txt'   => 'metapad "%s"',
    'doc'   => 'winword "%s"',
    'xls'   => 'excel "%s"',

    'x'     => 'SPECIAL',
    'lst'   => 'metapad "%s"',
    );

our $nfs_path_container;
our $nfs_path_vol;                          # dynamic: maybe happened to be override in any level of container.
our $nfs_path_full;                         # should be equal to container/title


our $opt_root;                              # NFS-Root, default "My Documents/.notes" -or- "~/.notes" for most types.

our $opt_program = '.dep';                  # Program used to open nfs document
                                            #   .dep    Depends on type
                                            #   .del    delete document
                                            #   .new    delete and create
                                            #   .map    copy document to specified directory
                                            #   .sync   synchronize the mappings in current directory
                                            #   .link   create a symbolic link of the specified container-name
                                            #   .index  build index file
                                            #   .bak    do backup
                                            #   .ls     browsing in the directory

our $opt_type = 'txt';                      # Document type
our $opt_type_specified = 0;                # Is the type option be strictly specified

our $opt_open_all = 0;                      # Open all types
                                            # If none type of the document is created, then create one;
                                            # Otherwise, ignore option --type

our $opt_map_target = '.';                  # Map the specified nfs document to the target directory
our $opt_map_delete = 0;                    # Delete the target mapping entry

our $opt_link = '.';                        # This relative path will be expanded to actual path.

our $opt_offset = 0;                        # Time or Serial adjustment

our $opt_index_range;                       # Documents range specifies which documents to be indexed

our $opt_keywords_range;                    # default "h1 keywords title"

our $opt_flatten_target;                    # flatten symbolic links into single directory-tree

our $opt_name_method = 'date';              # one of (date, ser)
our $opt_format_date = 'YYYY-MM-DD';
our $opt_format_serial = 'DDDD';
our $opt_title = '';                        # NFS-Title, Default depends on name-method
our $opt_max_levels = 'inf';                # Max levels of directories

our $opt_disable_symbolic_link = 0;
our $opt_disable_template_substitute = 0;
our $opt_disable_vex_extension = 0;

our $opt_interactive = 0;
our $opt_test_only = 0;
our $opt_verbose = 0;
our $opt_quiet = 0;


# Pre-declaration
    sub file_sync;
    sub expand_nfs_title;
    sub template_instantiate;
    sub template_substitute;
    sub auto_mkdir;
    sub expand_symbolic_link;
    sub binary_copy;
    sub get_serial;
    sub get_vol_serial;
    sub error_report;
    sub set_program;
    sub set_option;
    sub confirm_prompt;
    sub cmdexec;
    sub version;
    sub help;



sub main {
    GetOptions(
        'root|r=s',
        'nfs-title|n=s',
        'program|p=s'       => sub { set_program $_[1] },
        'type|t=s'          => sub { error_report "--open-all is specified" if $opt_open_all == 1;
                                     $opt_type = $_[1];
                                     $opt_type_specified = 1 },
        'open-all|a'        => sub { error_report "--type is specified" if $opt_type_specified;
                                     $opt_open_all = 1 },
        'backup|b'          => sub { set_program '.bak' },
        'create|c'          => sub { set_program '.new' },
        'delete|d'          => sub { set_program '.del' },
        'map|m:s'           => sub { set_program '.map';
                                     set_option "map target", \$opt_map_target, $_[1], '.' },
        'synchronize|s'     => sub { set_program '.sync' },
        'link|l:s'          => sub { set_program '.link';
                                     set_option "symbolic link file", \$opt_link, $_[1] },
        'index|x:s'         => sub { set_program '.index';
                                     set_option "index range", \$opt_index_range, $_[1] },
        'keywords|k:s'      => sub { set_program '.keys';
                                     set_option "keywords range", \$opt_keywords_range, $_[1] },
        'flatten|fl=s'      => sub { set_program '.flat';
                                     set_option "flatten target", \$opt_flatten_target, $_[1] },
        'max-levels|ml=s',
        'use-date|ud:s'     => sub { $opt_name_method = 'date';
                                     set_option "date format", \$opt_format_date, $_[1], $opt_format_date },
        'use-serial|us:s'   => sub { $opt_name_method = 'ser';
                                     set_option "serial format", \$opt_format_serial, $_[1], $opt_format_serial },
        'offset|o=n',
        'disable-symbolic-link|ds',
        'disable-template-substitute|dt',
        'disable-vex-extension|dv',
        'interactive|i',
        'test-only|to',
        'verbose|v',
        'quiet|q',
        'force|fo',
        'version|ve'        => sub { &version; exit },
        'help|h'            => sub { &help; exit },
        );

    for (@ARGV) {
        if ($_ eq '//') {               # //        --index
            set_program '.index';
        } elsif (m/^\/(\w+)$/) {        # /ext      --type
            error_report "--open-all is specified" if $opt_open_all == 1;
            $opt_type = $1;
            $opt_type_specified = 1;
        } elsif (m/^(\d+)\.$/) {        # num.      --offset=-num
            $opt_offset -= $1;
        } elsif (m/^(\.+)$/) {          # ...       --offset=-2
            $opt_offset -= length($1)-1;
        } elsif (m/^\.(\d+)$/) {        # .num      --offset=+num
            $opt_offset += $1;
        } elsif ($opt_title eq '') {      # <title>   --nfs-title
            # REM-ARG-1 for title is title not defined
            $opt_title = $_;
        } else {
            die "Invalid argument: $_";
        }
    }

    if (! defined $opt_root) {
        if ($opt_type eq 'x') {
            $opt_root = "$ENV{USERPROFILE}/My Documents/.scratch";
            $opt_type = 'lst';
            $opt_program = '.ls';
        } else {
            $opt_root = "$ENV{USERPROFILE}/My Documents/.notes";
        }
    }

    if ($opt_title eq '') {
        my $deftitle = get_serial($opt_root);
        if ($opt_interactive) {
            set_option 'nfs title', \$opt_title, '', $deftitle;
        } else {
            $opt_title = $deftitle;
        }
    }

    if ($opt_title =~ m/--/) {
        die "Invalid NFS-Title: $opt_title";
    }

    $opt_root = expand_symbolic_link($opt_root, 'Not mounted: %s');

    # prepare title name
        if ($opt_title =~ m/^\.(.*)$/) {
            $opt_title = ".vol-$1";
        }

        if ($opt_title =~ s/-$/-placeholder/) {
            # temporary add the serial-name for stacked-document (which has '-' suffix)

            # get the container path
            my ($t_container, $t_vol, $t_full, $t_autoext)
                = expand_nfs_title($opt_root, $opt_title, $opt_type, 1);

            my $stack_serial = get_serial($t_container);
            $opt_title =~ s/-placeholder$//;
            $opt_title .= "-$stack_serial";
        }

    # expand nfs-title into container-path and full-path
        ($nfs_path_container,
         $nfs_path_vol,
         $nfs_path_full,
         $opt_type)
            = expand_nfs_title($opt_root, $opt_title, $opt_type, $opt_type_specified);

        print "NFS-Vol:   \"$nfs_path_vol\"\n" if $opt_verbose;
        print "Container: \"$nfs_path_container\"\n" if $opt_verbose;
        print "Fullpath:  \"$nfs_path_full\"\n" if $opt_verbose;

        print "Program:   \"$opt_program\"\n" if $opt_verbose;

    # quick delete
        if ($opt_program eq '.del' or $opt_program eq '.new') {
            if (-e $nfs_path_full) {
                my $confirm = confirm_prompt "delete file $nfs_path_full";
                exit if not $confirm;
                print "delete file $nfs_path_full\n" if $opt_verbose;
                if (not unlink $nfs_path_full) {
                    print "Nfs document $nfs_path_full can not be deleted\n" if $opt_quiet;
                }
            } else {
                print "Nfs document $nfs_path_full was not existed\n" if not $opt_quiet;
            }
            exit if ($opt_program eq '.del');
            undef $opt_program;         # for .new
        }


    # for special operations

    if ($opt_program eq '.bak') {
        print "backup $nfs_path_full to $nfs_path_full.bak\n" if $opt_verbose;
        binary_copy $nfs_path_full, "$nfs_path_full.bak";
        return;
    }

    if ($opt_program eq '.map') {
        print "map $nfs_path_full to $opt_map_target\n" if $opt_verbose;

        # check source existance and get the extension
        if (not $opt_map_delete) {
            if (not -e $nfs_path_full) {
                die "Mapping source $nfs_path_full isn't existed. ";
            }
        }
        if ($opt_map_target !~ m/\./) {
            $opt_map_target .= ".$opt_type";
        }

        if ($opt_map_delete) {
            if (-e $opt_map_target) {
                my $confirm = "delete file $opt_map_target";
                exit if not $confirm;
            }
            unlink $opt_map_target;
        } else {
            # returns the actually full-path of target,
            # this may fill the ignored filename
            $opt_map_target = binary_copy($nfs_path_full, $opt_map_target);
        }

        if (not $opt_disable_vex_extension) {
            # $new_this -> $new_source
            my ($src_dir, $src_name) = path_split($nfs_path_full);
            my ($dst_dir, $dst_name) = path_split($opt_map_target);
                $dst_dir ||= '.';
            my $new_key = $dst_name;            # target
            my $new_value = $nfs_path_full;     # source

            my $vexdir = path_join($dst_dir, '.VEX', 'sync');
            my $synclist = path_join($vexdir, 'sync-nfs');

            if ($opt_map_delete) {
                print "remove vex/sync entry: $new_key=$new_value\n" if $opt_verbose;
            } else {
                # os-branch
                # if (not -e ".sync-nfs.bat") {
                    open(F, ">.sync-nfs.bat");
                    print F "\@echo off\n";
                    print F "rem NFS-Rev: $nfs_id{rev}\n";
                    print F "rem Thie file is auto generated by NFS Program $nfs_id{rev}, and it will\n";
                    print F "rem be automaticly updated. Please don't edit this file. \n";
                    print F "call nfs --synchronize --quiet\n";
                    close F;
                # }

                print "add vex/sync entry: $new_key=$new_value\n" if $opt_verbose;
                auto_mkdir $vexdir;
            }

            my @lines = ();
            if (open(SYNC, "<$synclist")) {
                while (<SYNC>) {
                    if (m/^\s*(\#.*)$/) {
                        push @lines, $_;
                        next;
                    }
                    if (m/^(.*)=(.*)$/) {
                        next if ($1 eq $new_key);
                    }
                    push @lines, $_;
                }
                close SYNC;
            }
            if (not $opt_map_delete) {
                push @lines, "$new_key=$new_value\n";
            }
            if (@lines) {
                open(SYNC, ">$synclist")
                    or die "Can't open $synclist for write";
                for (@lines) {
                    print SYNC;
                }
                close SYNC;
            } else {
                unlink $synclist;

                # os-branch
                if (-e ".sync-nfs.bat") {
                    unlink ".sync-nfs.bat";
                }
            }
        }
        return;
    }

    if ($opt_program eq '.sync') {
        if ($opt_disable_vex_extension) {
            # treat all files under current directory as mapping-items
            my $dh = new DirHandle('.');
            my @files = $dh->read;
            $dh->close;
            while (@files) {
                next if (m/^\.+$/);
                my $fullpath = expand_nfs_title($_);
                if (-e $fullpath) {
                    print "synchronize $_ from $fullpath\n" if $opt_verbose;
                    file_sync $fullpath, path_join('.', $_), $_;
                }
            }
        } else {
            my $vexdir = path_join($opt_map_target, '.VEX', 'sync');
            my $synclist = path_join($vexdir, 'sync-nfs');
            if (not -e $vexdir) {
                print "no items to synchronize\n" if $opt_verbose;
                exit;
            }

            if (open(SYNC, "<$synclist")) {
                while (<SYNC>) {
                    next if (m/^\s*(\#.*)$/);
                    if (m/^(.*)=(.*)$/) {
                        my $synckey = $1;                       # sync-target
                        my $syncvalue = $2;                     # sync-source
                        print "synchronize $synckey from $syncvalue\n" if $opt_verbose;
                        file_sync $syncvalue, path_join('.', $synckey), $synckey;
                    }
                }
                close SYNC;
            }
        }
        return;
    }

    # for normal open

    # browsing?
    if ($opt_program eq '.ls') {
        my $termdir = path_join $nfs_path_container, $opt_title;
        auto_mkdir $termdir;
        $opt_program = '.dep';
        cmdexec "start \"$termdir\"";
        # continue operations.
    }

    # lazy- create
    if (! -e $nfs_path_full) {
        # auto create the container levels
        auto_mkdir $nfs_path_container;

        # apply the template
        my $template = path_join $nfs_path_vol, ".vol-def.$opt_type";
        if (-e $template) {
            print "create new nfs document based on template: $template\n" if $opt_verbose;
            template_instantiate $template, $nfs_path_full;
        } else {
            print "create new nfs document (empty)\n" if $opt_verbose;
            open(FH, ">$nfs_path_full")
                or die "Can't create file $nfs_path_full";
            close FH;
        }
    }

    # prepare file-list to open => $full_dir/$full_name . @exts
    my ($full_dir, $full_file) = path_split $nfs_path_full;
    my ($full_name, $full_ext) = path_splitext $full_file;
        $full_ext =~ s/^\.//;
    my @exts;

    if ($opt_open_all) {
        my $dh = new DirHandle($nfs_path_container);
        my @list = $dh->read;
        $dh->close;
        foreach my $item (@list) {
            next if -d path_join($nfs_path_container, $item);
            my ($et_name, $et_ext) = path_splitext $item;
            $et_ext =~ s/^\.//;
            push @exts, $et_ext if ($et_name eq $full_name);
        }
    }
    @exts = ($full_ext) if (not @exts);

    # open file-list
    foreach my $each_ext (@exts) {
        my $open_path = path_join($full_dir, "$full_name.$each_ext");
        my $cmdline;

        if ($opt_program eq '.dep') {
            # use program depends on type to open the document
            my $opener = $nfs_filetype{$each_ext};
               $opener ||= $nfs_filetype{''};
            $cmdline = sprintf("start $opener", $open_path);
        } else {
            # use the specified program to open the document
            $cmdline = sprintf("start $opt_program", $open_path);
        }

        cmdexec $cmdline;
    }

}



###############################################################################
#
# SUBROUTINES
#
#   file_sync
#   expand_nfs_title
#   template_instantiate
#   auto_mkdir
#   expand_symbolic_link
#   binary_copy
#   get_serial
#   get_vol_serial
#   version
#   help

sub file_sync {
    my ($source, $dest, $name) = @_;
    if (not -e $dest) {
        print "download/new $name\n" if not $opt_quiet;
        binary_copy $source, $dest;
    } elsif (not -e $source) {
        print "upload/new $name\n" if not $opt_quiet;
        binary_copy $dest, $source;
    } else {
        my @st_src = stat $source;
        my @st_dst = stat $dest;
        my $mt_src = $st_src[9];
        my $mt_dst = $st_dst[9];
        if ($mt_src == $mt_dst) {
            print "skip $name\n" if not $opt_quiet;
        } elsif ($mt_src > $mt_dst) {
            # source is newer
            print "download $name\n" if not $opt_quiet;
            binary_copy $source, $dest;
        } else {
            # dest is newer
            print "upload $name\n" if not $opt_quiet;
            binary_copy $dest, $source;
        }
    }
}


# input:    original-root, title
# output:   path-container, path-vol, path-full
sub expand_nfs_title {
    my ($root, $title, $ext, $strict) = @_;
    my @segs = split('-', $title);
    my $current = '';
    my ($container, $vol, $full);

    for (@segs) {
        $current .= '-' if $current;
        $current .= $_;
        $_ = $current;
    }
    my $name = pop @segs;

    $container = $root;
    $vol = path_join $root, '.vol';
    for (@segs) {
        $container .= '/' if $container;
        $container .= $_;
        $container = expand_symbolic_link($container, 'Link target not existed: %s');
        if (-d path_join($container, '.vol')) {
            $vol = path_join $container, '.vol';
        }
    }
    $container = path_normalize $container;
    $vol = path_normalize $vol;

    if (not $strict and -d $container) {
        # auto find extension
        my $dh = new DirHandle($container);
        my @list = $dh->read;
        $dh->close;
        my $autoext = undef;
        for (@list) {
            next if -d path_join($container, $_);
            my ($fi, $ei) = path_splitext($_);
            $ei =~ s/^\.//;
            if ($fi eq $name) {
                $autoext = $ei if not $autoext;
                $autoext = $ei if $ei eq $ext;        # high prior for same-extension
            }
        }
        $ext = $autoext if $autoext;
    } else {
        # extension strictly specified
        # (do nothing)
    }

    $full = path_join $container, "$name.$ext";
    return ($container, $vol, $full, $ext);
}


sub template_instantiate {
    my ($temp, $file) = @_;
    my @noteauto_supports = qw/doc xls/;
    if (grep { $_ eq $opt_type } @noteauto_supports) {
        # e.g.
        #   noteauto path/vol create doc path/full.ext
        #   noteauto path/vol create xls path/full.ext
        system "noteauto \"$nfs_path_vol\" create $opt_type \"$nfs_path_full\"";
    } else {
        print "instantating $temp to $file\n" if $opt_verbose;
        open(FSRC, "<$temp")
            or die "Can't open file $temp for read";
        open(FDEST, ">$file")
            or die "Can't open file $file for write";
        while (<FSRC>) {
            if (not $opt_disable_template_substitute) {
                $_ = template_substitute $_;
            }
            print FDEST;
        }
        close FSRC;
        close FDEST;
    }
}


sub template_substitute {
    # Format <? Perl-scriptlet ?> must be in one-line
    my $oldtext = shift;

    # Copy from re-parts.pl
    # Complex-Replacement based:
            my $newtext = '';
            my $posmark = 0;
            while ($oldtext =~ m/ <\? ( ( (\\.) | ([^\?]) | (\?[^>]) )* ) \?> /xg) {
		$newtext .= substr($oldtext, $posmark, $-[0] - $posmark);

		my $scriptlet = $1;
		my $result = eval($scriptlet);
		$newtext .= $result;
		print "template substitute: <?$scriptlet?> => $result\n" if $opt_verbose;

		$posmark = $-[0] + length($&);
            }
            $newtext .= substr($oldtext, $posmark);

    return $newtext;
}


sub auto_mkdir {
    my $path = shift;
    print "auto_mkdir $path\n" if $opt_verbose;

    my @segs = path_segs($path);
    my $current;
    for (@segs) {
        $current .= '/' if $current;
        $current .= $_;
        $_ = $current;
        if (not -e) {
            print "mkdir $_\n" if $opt_verbose;
            mkdir $_;
        }
    }
    return -d $path;
}


sub expand_symbolic_link {
    my ($path, $errmsg) = @_;
    return $path if $opt_disable_symbolic_link;

    chop $path if $path =~ m/[\\\/]$/;

    if (-f "$path") {
        open(F, "<$path")
            or die "Can't open symbolic-link file";
        my @lines = <F>;
        close F;

        # remove blank and comments lines
        @lines = grep {!/^\s*(\#.*)?$/} @lines;
        my $content = join('', @lines);
        $content = template_substitute($content);
        chomp $content;

        my $context_dir = path_join($path, '..');
        $path = path_join($context_dir, $content);

        if (not -e $path and $errmsg) {
            $errmsg = sprintf $errmsg, $path;
            print($errmsg), exit if $opt_test_only;
            while ('retry' eq
                    msgbox($errmsg, $nfs_appname, 'retry', 'cancel', 'x')) {
                last if -e $path;
            }
            exit if not -e $path;
        }

        return $path;
    }
    return $path;
}


sub binary_copy {
    my ($src, $dest) = @_;
    if (-d $dest) {
        my ($src_dir, $srcfile) = path_split($src);
        $dest = path_join($dest, $srcfile);
    }

    if (-e $dest) {
        my $confirm = confirm_prompt "overwrite file $dest";
        exit if not $confirm;
    }

    print "copy $src to $dest\n" if $opt_verbose;

    #open(FSRC, "<$src")
    #    or die "Can't open file $src for read";
    #open(FDEST, ">$dest")
    #    or die "Can't open file $dest for write";
    #binmode FSRC;
    #binmode FDEST;
    #while (<FSRC>) {
    #    print FDEST;
    #}
    #close FSRC;
    #close FDEST;

    copy($src, $dest)
        or die "Can't copy $src to $dest";

    return $dest;
}


sub get_serial {
    if ($opt_name_method eq 'date') {
        # YYYY-MM-DD (week W) HH:NN:SS
        my $fmt = '';
        my @list = ();
        my $timestamp = time + $opt_offset * 86400;
        my @lt = localtime $timestamp;
        while ($opt_format_date =~ m/(.)\1*/g) {
            my $c = substr($&, 0, 1);
            my $len = length($&);
            my $f = '%0'.$len.'d';

            if ($c eq 'Y')      { $fmt .= $f; push @list, 1900 + $lt[5] }
            elsif ($c eq 'M')   { $fmt .= $f; push @list,    1 + $lt[4] }
            elsif ($c eq 'D')   { $fmt .= $f; push @list,    0 + $lt[3] }
            elsif ($c eq 'W')   { $fmt .= $f; push @list,    0 + $lt[6] }
            elsif ($c eq 'H')   { $fmt .= $f; push @list,    0 + $lt[2] }
            elsif ($c eq 'N')   { $fmt .= $f; push @list,    0 + $lt[1] }
            elsif ($c eq 'S')   { $fmt .= $f; push @list,    0 + $lt[0] }
            else                { $fmt .= $&; }
        }
        return sprintf($fmt, @list);
    }
    if ($opt_name_method eq 'ser') {
        if ($opt_format_serial !~ m/^(.)\1*$/) {
            die "Invalid serial format: $opt_format_serial";
        }
        my $c = substr($&, 0, 1);
        my $pad = 0;
        my $ordix = 10;
        my $capital = 0;
        if ($c eq 'h') { $ordix = 16; $pad = 0 }
        if ($c eq 'H') { $ordix = 16; $pad = 1 }
        if ($c eq 'x') { $ordix = 16; $pad = 0; $capital = 1 }
        if ($c eq 'X') { $ordix = 16; $pad = 1; $capital = 1 }
        if ($c eq 'd') { $ordix = 10; $pad = 0 }
        if ($c eq 'D') { $ordix = 10; $pad = 1 }
        if ($c eq 'o') { $ordix =  8; $pad = 0 }
        if ($c eq 'O') { $ordix =  8; $pad = 1 }
        my $len = length($opt_format_serial);

        my $f = '%';
        $f .= '0' if $pad;
        $f .= $len;
        $f .= 'd' if $ordix == 10;
        $f .= 'o' if $ordix == 8;
        $f .= 'x' if $ordix == 16 and $capital = 0;
        $f .= 'X' if $ordix == 16 and $capital = 1;
        my $container = shift;
        print "calculate the container-serial for $container\n" if $opt_verbose;

        my $dh = new DirHandle($container);
        my @files = $dh->read;
        $dh->close;

        my ($min, $max) = (0, 0);
        my $num;
        for (@files) {
            next if (-d path_join($container, $_));
            s/^.*-//;
            if ($ordix == 10) {
                $num = 1 * $_;
            } elsif ($ordix == 8) {
                $num = oct $_;
            } elsif ($ordix == 16) {
                $num = hex $_;
            }
            # print "container-serial number discovered: $num\n" if $opt_verbose;
            $min = $num if $num < $min;
            $max = $num if $num > $max;
        }
        print "last container-serial retrieved: $max\n" if $opt_verbose;
        $num = $max + 1 + $opt_offset;

        return sprintf($f, $num);
    }
    die "Name method $opt_name_method is not supported. ";
}


sub get_vol_serial {
    my $serial = 0;
    my $path_serial = path_join($nfs_path_vol, '.vol-serial');
    if (-e $path_serial) {
        open(F, "<$path_serial")
            or die "Can't open serial file $path_serial to read";
        $serial = 1 * <F>;
        print "last serial retrieved: $serial\n" if $opt_verbose;
        close F;
    }
    $serial++;
    open(F, ">$path_serial")
        or die "Can't open serial file $path_serial to write";
    print F $serial;
    close F;
    return $serial;
}


sub error_report {
    my $msg = shift;
    print $msg;
    exit;
}

sub set_program {
    my $program = shift;
    if ($opt_program eq '.dep') {
        $opt_program = $program;
        return;
    }
    if ($opt_program eq '.map') {
        if ($program eq '.del') {
            $opt_map_delete = 1;
            return;
        }
    }
    error_report "--program=$opt_program has already been specified"
}

sub set_option {
    my ($prompt, $optvar, $optval, $defval) = @_;
    if ($opt_interactive) {
        if ($optval eq '') {
            print "Enter $prompt: ";
            my $userinput = <>;
            chomp $userinput;
            $optval = $userinput;
        }
    }
    $optval = $defval if $optval eq '';
    $$optvar = $optval;
}

sub confirm_prompt {
    my $prompt = shift;
    return 1 if $opt_quiet;

    while (1) {
        print "Confirm $prompt? ([y]es, [n]o) ";
        my $userinput = <>;
        chomp $userinput;
        $userinput = lc $userinput;

        return 1 if $userinput =~ m/y(e(s)?)?/;
        return 0 if $userinput =~ m/n(o)?/;
        print "Please enter yes or no. ";
    }
}


sub cmdexec {
    my $cmdline = shift;
    print "$cmdline\n" if $opt_verbose;
    if ($opt_test_only) {
        # do nothing
        my $local = $nfs_path_container;
        chdir $local;

        $local =~ s {\/}{\\}g;
        print "HOWTO? - cd \"$local\"";
    } else {
        system $cmdline;
    }
}


sub version {
    print <<"EOM"
[NFS] Notes for Speed
      Written by Snima Denik    Version 2.$nfs_id{rev}    Updated $nfs_id{date}
EOM
}


sub help {
    &version;
    print <<"EOM";

Syntax:
    nfs (-abcdhilmnopqrstuvx <title>)
        --root=<nfs-root, default "~/My Documents/.notes" for Windows, -or-
                "~/.notes" for *Nix> (r)
        --nfs-title=<nfs-title, default use-date> (n)
        --program=<open-by-program, default depends on type> (p)
        --type=<note-file-type, default txt> (t)
        --open-all (a)
            (open all types of the specifid note, exclusive with --type)

        --backup (b)
        --create (delete the existing document and create new) (c)
        --delete (d)
        --map=<target-directory, default current directory> (m)
        --synchronize (synchronize the mappings in current directory) (s)
        --link=<directory on which the .link file resides> (l)
               (create a symbolic link of the specified container-name)
        --index=<index-range, default "h1"> (x)

        --keywords-build=<keywords-range, default "h1 keywords title"> (k)
        --flatten=<target-directory> (f)
                  (flatten symbolic links into single directory-tree)

        --max-levels=<1..inf, default inf> (ml)

        --use-date=<date-format, default YYYY-MM-DD> (ud)
        --use-serial=<serial-format, default 000> (us)
        --offset=<days for date -or- number for serial, default -1> (o)

        --disable-symbolic-link (ds)
        --disable-template-substitute (dt)
        --disable-vex-extension (dv)
        --interactive (i)
        --test-only (to)
        --verbose (v)
        --quiet (q)
        --version (ve)
        --help (h)

        [--] <nfs-title>

This program is distributed under GNU General Public License (GPL).
Send bug-report to bug-report\@bodz.net, or visit http://tc.bodz.net/diret
EOM
}

&main;
