#!/usr/bin/perl

use strict;
use Getopt::Long;
use FileHandle;
use DirHandle;


my $recursive = 0;
my $backup_file = 0;
my $regex = 0;
my $binary = 0;
my $no_case = 0;
my $first_n = 0;

my $force = 0;
my $quiet = 0;
my $verbose = 0;

my $options = GetOptions(
                         'recursive|r' => \$recursive,
                         'backup|k' => \$backup_file,
                         'regular-expression|x' => \$regex,
                         'binary|b' => \$binary,
                         'first|n=n' => \$first_n,
                         'ignore-case' => \$no_case,
                         'force' => \$force,
                         'quiet' => \$quiet,
                         'verbose' => \$verbose,
                         'help|?' => sub { &help },
                         );

help() if (scalar(@ARGV) < 3);

my ($fpat, $source, $target, @files) = @ARGV;
$fpat =~ s/\./\\./g;
$fpat =~ s/\*/.*/g;
$fpat =~ s/\?/./g;
$fpat = qr/$fpat/i;

print "normalized-file-pattern: $fpat\n" if $verbose;

my $n_source = length($source);
my $n_target = length($target);
$source = lc($source) if $no_case;
$source = qr/$source/i if $regex and $no_case;
$source = qr/$source/  if $regex and not $no_case;

@files = '.' if (scalar(@files) == 0);

if ($regex) {
	# process reg-ex escapes
} else {
	# process text escapes
}


for (@files) {
	# always enter into the specified directories
	process_file($_, 1);
}


sub process_file {
	my ($file, $recur) = @_;

	if (-d $file) {
		print "d $file\n" if $verbose;
		my $count = 0;
		if ($recur) {
			my $dir = new DirHandle($file);
			my @list = $dir->read;
			for (@list) {
				# print "[".join(',',@list)."]\n" if $verbose;
				next if (m/^\.\.?$/);

				my $fpath = "$file/$_";
				if (-f $fpath) {
					#print "s $file\n" if $verbose;
					next if ($fpath !~ m/$fpat/);
				}

				$count += process_file($fpath, $recursive);
			}
		}
		return $count;
	}

	print "f $file\n" if not $quiet;
	my $fh = new FileHandle($file);
	my @lines = <$fh>;
	$fh->close();

	if ($backup_file) {
		print "w $file.bak\n" if $verbose;
		my $fh_bak = new FileHandle("$file.bak");
		$fh_bak->write(@lines);
		$fh_bak->close();
	}

	my $dirty = 0;

	for (my $l = 0; $l < scalar(@lines); $l++) {
		$_ = $lines[$l];
		if ($regex) {
			if (s/$source/$target/g) {
				$dirty = 1;
			}
		} else {
			my $pos = $[;
			while (1) {
				if ($no_case) {
					$pos = index(lc($_), $source, $pos);
				} else {
					$pos = index($_, $source, $pos);
				}
				last if ($pos < $[);

				substr($_, $pos, $n_source) = $target;
				$pos += $n_target;
				$dirty = 1;
			}
		}
		$lines[$l] = $_;
	}

	if ($dirty) {
		print "w $file\n" if not $quiet;
		#print "result\n";
		#print join("\n", @lines);
		$fh = new FileHandle(">$file");
		$fh->write(join("\n", @lines));
		$fh->close();
		return 1;
	}
	return 0;
}

sub help() {
	print <<"EOM";
REPLace files    Author/Danci.Z    Version/3    Date/Aug 22 2004
Syntax:
    repl
        --recursive (r)
        --backup (k)
        --regular-expression (x)
        --binary (b)
        --first=<number> (n)
        --ignore-case (i)
        --force (f)
        --quiet (q)
        --verbose (v)
        --help (?)
        <file-pattern (reg-ex except .  ?  * instead of  \\.  .  .* )>
        <source-pattern (reg-ex or plain-text)>
        <target-pattern (reg-ex or plain-text)>
        [files or directories ... (default is current directory '.') ]
EOM
	exit 0;
}
