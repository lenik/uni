#!/usr/bin/perl

# $id$
# $log$

use strict;
use Getopt::Long;
use FileHandle;
use DirHandle;


my $recursive = 0;
my $backup_file = 0;
my $regex = 0;
my $binary = 0;
my $no_case = 0;
my $first_n = 0;

my $command;
my $cmd_exec;
my $cmd_args;
my $force = 0;
my $quiet = 0;
my $verbose = 0;

my $options = GetOptions(
                         'recursive|r' => \$recursive,
                         'backup|k' => \$backup_file,
                         'regular-expression|x' => \$regex,
                         'binary|b' => \$binary,
                         'first|n=n' => \$first_n,
                         'ignore-case' => \$no_case,
                         'force' => \$force,
                         'quiet' => \$quiet,
                         'verbose' => \$verbose,
                         'help|?' => sub { &help },
                         'command=s' => \$command,
                         );


help() if ($command and scalar(@ARGV) < 1);
help() if (!$command and scalar(@ARGV) < 3);

($cmd_exec, $cmd_args) = $command =~ m/^(.+?)(?:::(.*))?$/ if $command;

my ($fpat, $source, $target, @files) = @ARGV;
$fpat =~ s/\./\\./g;
$fpat =~ s/\*/.*/g;
$fpat =~ s/\?/./g;
$fpat = qr/$fpat/i;

print "normalized-file-pattern: $fpat\n" if $verbose;

my $n_source = length($source);
my $n_target = length($target);
$source = lc($source) if $no_case;
$source = qr/$source/i if $regex and $no_case;
$source = qr/$source/  if $regex and not $no_case;

@files = '.' if (scalar(@files) == 0);

if ($regex) {
	# process reg-ex escapes
} else {
	# process text escapes
}


for (@files) {
	# always enter into the specified directories
	process_file($_, 1);
}


sub process_file {
	my ($file, $recur) = @_;

	if (-d $file) {
		print "d $file\n" if $verbose;
		my $count = 0;
		if ($recur) {
			my $dir = new DirHandle($file);
			my @list = $dir->read;
			for (@list) {
				# print "[".join(',',@list)."]\n" if $verbose;
				next if (m/^\.\.?$/);

				my $fpath = "$file/$_";
				if (-f $fpath) {
					#print "s $file\n" if $verbose;
					next if ($fpath !~ m/$fpat/);
				}

				$count += process_file($fpath, $recursive);
			}
		}
		return $count;
	}

	print "f $file\n" if not $quiet;
	my $fh = new FileHandle("<$file");
	my @lines = <$fh>;
	$fh->close();

	if ($backup_file) {
		print "w $file.bak\n" if $verbose;
		my $fh_bak = new FileHandle("$file.bak");
		$fh_bak->write(@lines);
		$fh_bak->close();
	}

	my $dirty = 0;

	if ($command) {
		# repl.pl -c <command-line> <files-pattern> <source> <target>
		my $cmd_arg_parsed = eval("\"$cmd_args\"");
		print "x $cmd_exec $cmd_arg_parsed\n";

		# run external program
		my @outs = `$cmd_exec $cmd_arg_parsed`;

		if (scalar(@lines) != scalar(@outs)) {
			$dirty = 1;
		} else {
			for (my $l = 0; $l < scalar(@lines); $l++) {
				if ($lines[$l] ne $outs[$l]) {
					$dirty = 1;
					last;
				}
			}
		}
		@lines = @outs if $dirty;
	} else {
		# default replace implementation
		for (my $l = 0; $l < scalar(@lines); $l++) {
			$_ = $lines[$l];
			if ($regex) {
				if (s/$source/$target/g) {
					$dirty = 1;
				}
			} else {
				my $pos = $[;
				while (1) {
					if ($no_case) {
						$pos = index(lc($_), $source, $pos);
					} else {
						$pos = index($_, $source, $pos);
					}
					last if ($pos < $[);

					substr($_, $pos, $n_source) = $target;
					$pos += $n_target;
					$dirty = 1;
				}
			}
			$lines[$l] = $_;
		}
	}

	if ($dirty) {
		print "w $file\n" if not $quiet;
		#print "result\n";
		#print join("\n", @lines);
		$fh = new FileHandle(">$file");
		$fh->write(join("", @lines));
		$fh->close();
		return 1;
	}
	return 0;
}

sub help() {
	print <<"EOM";
REPLace files    Author/Danci.Z    Version/3    Date/Aug 22 2004
Syntax:
    $0
        --recursive (r)
        --backup (k)
        --regular-expression (x)
        --command=<external-command::arguments(\$var-names)> (c)
        --binary (b)
        --first=<number> (n)
        --ignore-case (i)
        --force (f)
        --quiet (q)
        --verbose (v)
        --help (?)
        <file-pattern (reg-ex except .  ?  * instead of  \\.  .  .* )>
        <source-pattern (reg-ex or plain-text)>
        <target-pattern (reg-ex or plain-text)>
        [files or directories ... (default is current directory '.') ]
EOM
	exit 0;
}
