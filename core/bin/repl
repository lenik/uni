#!/usr/bin/perl

use strict;
use cmt::util;
use cmt::vcs;
use DirHandle;
use FileHandle;
use Getopt::Long;

sub boot;
sub main;
sub info;
sub info2;
sub info3;
sub version;
sub help;

sub process_file;

our $opt_verbtitle      = 'repl';
our $opt_verbtime       = 0;
our $opt_verbose        = 2;
our $opt_recursive      = 0;
our $opt_backup_file    = 0;
our $opt_regex          = 0;
our $opt_binary         = 0;
our $opt_no_case        = 0;
our $opt_first_n        = 0;
our $opt_force          = 0;
our $opt_output_only    = 0;
our $opt_command;
our $cmd_exec;
our $cmd_args;
our $fpat;
our ($source, $target);
our ($n_source, $n_target);

sub boot {
    GetOptions('quiet|q'    => sub { $opt_verbose-- },
               'verbose|v'  => sub { $opt_verbose++ },
               'version'    => sub { version; exit },
               'help|h'     => sub { help; exit },
               'recursive|r',
               'backup|k',
               'regex|x',
               'binary|b',
               'output|o',
               'first|n=n',
               'ignore-case|i',
               'force|f',
               'command|c=s',
               );

    if ($opt_output_only) {
        $opt_backup_file = 0;
        $opt_verbose--;
    }

    if ( $opt_command  and scalar(@ARGV) < 1 ) { help; exit }
    if ( !$opt_command and scalar(@ARGV) < 3 ) { help; exit }

    ( $cmd_exec, $cmd_args ) =
        $opt_command =~ m/^(.+?)(?:::(.*))?$/ if $opt_command;

    $fpat   = shift @ARGV;
    $source = shift @ARGV;
    $target = shift @ARGV;
    $fpat =~ s/\./\\./g;
    $fpat =~ s/\*/.*/g;
    $fpat =~ s/\?/./g;
    $fpat = qr/$fpat/i;

    info3 "normalized-file-pattern: $fpat";

    $n_source = length($source);
    $n_target = length($target);
    if ($opt_regex) {
        if ($opt_no_case) {
            $source = qr/$source/i;
        } else {
            $source = qr/$source/;
        }
    } else {
        $source = lc($source) if $opt_no_case;
    }
    info3 "source pattern: $source";

    if ($opt_regex) {

        # process reg-ex escapes
    }
    else {

        # process text escapes
    }

    main;
}

sub info {
    return if $opt_verbose < 1;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub info2 {
    return if $opt_verbose < 2;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub info3 {
    return if $opt_verbose < 3;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub version {
    my %id = parse_id('$Id: repl,v 1.15 2007-06-25 14:11:42 lenik Exp $');
    print "[$opt_verbtitle] Replace files by regular-expression \n";
    print "Written by Lenik,  Version $id{rev},  Last updated at $id{date}\n";
}

sub help {
    &version;
    print <<"EOM";

Syntax:
    $0
        --recursive (r)
        --backup (k)
        --regular-expression (x)
        --command=<external-command::arguments(\$var-names)> (c)
        --binary (b)
        --output (o)
        --first=<number> (n)
        --ignore-case (i)
        --force (f)
        --quiet (q)
        --verbose (v)
        --help (?)
        <file-pattern (reg-ex except .  ?  * instead of  \\.  .  .* )>
        <source-pattern (reg-ex or plain-text)>
        <target-pattern (reg-ex or plain-text)>
        [files or directories ... (default is current directory '.') ]

Variables:
    \$fpat          file pattern
    \$source        source pattern
    \$target        target pattern
    \$file          current file name
EOM
}

boot;

sub main {
    my $total_dirty = 0;

    my @files = @ARGV;
    @files = '.' if ( scalar(@files) == 0 );

    for (@files) {
        # always enter into the specified directories
        $total_dirty += process_file( $_, 1 );
    }

    info "Total $total_dirty files are modified. ";
}

sub process_file {
    my ( $file, $recur ) = @_;

    if ( -d $file ) {
        info3 "d $file";
        my $count = 0;
        if ($recur) {
            my $dir  = new DirHandle($file);
            my @list = $dir->read;
            for (@list) {

                # info3 "[".join(',',@list)."]";
                next if (m/^\.\.?$/);

                my $fpath = "$file/$_";
                if ( -f $fpath ) {

                    # info3 "s $file";
                    next if ( $fpath !~ m/$fpat/ );
                }

                $count += process_file( $fpath, $opt_recursive );
            }
        }
        return $count;
    }

    info2 "f $file";
    my $fh = new FileHandle("<$file");
    return 0 if ( !$fh );

    my @lines = <$fh>;
    $fh->close();

    if ($opt_backup_file) {
        info3 "w $file.bak";
        my $fh_bak = new FileHandle("$file.bak");
        $fh_bak->write(@lines);
        $fh_bak->close();
    }

    my $dirty = 0;

    if ($opt_command) {

        # repl.pl -c <command-line> <files-pattern> <source> <target>
        my $cmd_arg_parsed = eval("\"$cmd_args\"");
        info "x $cmd_exec $cmd_arg_parsed";

        # run external program
        my @outs = `$cmd_exec $cmd_arg_parsed`;

        if ( scalar(@lines) != scalar(@outs) ) {
            $dirty = 1;
        }
        else {
            for ( my $l = 0 ; $l < scalar(@lines) ; $l++ ) {
                if ( $lines[$l] ne $outs[$l] ) {
                    $dirty = 1;
                    last;
                }
            }
        }
        @lines = @outs if $dirty;
    }
    else {

        # default replace implementation
        for ( my $l = 0 ; $l < scalar(@lines) ; $l++ ) {
            $_ = $lines[$l];
            if ($opt_regex) {
                my $res  = '';
                my $spos = 0;
                while (m/$source/g) {
                    $res .= substr( $_, $spos, $-[0] - $spos );
                    $res .= eval("\"$target\"");
                    $spos = $-[0] + length($&);
                }
                $res .= substr( $_, $spos );

                #print STDERR "[$_=>$res]\n";

                if ( $_ ne $res ) {
                    $_     = $res;
                    $dirty = 1;
                }
            }
            else {
                my $pos = $[;
                while (1) {
                    if ($opt_no_case) {
                        $pos = index( lc($_), $source, $pos );
                    }
                    else {
                        $pos = index( $_, $source, $pos );
                    }
                    last if ( $pos < $[ );

                    substr( $_, $pos, $n_source ) = $target;
                    $pos += $n_target;
                    $dirty = 1;
                }
            }
            $lines[$l] = $_;
        }
    }

    if ($opt_output_only) {
        for (@lines) {
            print;
        }
    }
    else {
        if ($dirty) {
            info "w $file";

            #print "result\n";
            #print join("\n", @lines);
            $fh = new FileHandle(">$file");
            $fh->write( join( "", @lines ) );
            $fh->close();
            return 1;
        }
    }

    return 0;
}
