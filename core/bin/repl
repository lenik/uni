#!/usr/bin/perl -w

# $Id: repl,v 1.11 2007-04-27 13:46:14 lenik Exp $
# $Log: not supported by cvs2svn $
# Revision 1.10  2006/11/17 20:28:09  lenik
# replace #!/usr/bin/perl -> #!perl
#
# Revision 1.9  2005/10/21 04:01:26  dansei
# die if file error
#
# Revision 1.8  2005/01/06 04:21:46  dansei
# fd.  cmt.pm => cmt/vcs.pm
#
# Revision 1.7  2004/12/12 07:32:52  dansei
# missing of "use cmt"
#
# Revision 1.6  2004/12/12 07:32:09  dansei
# split help into version and help,
# (cuz repl.pl was refered too much, its code will be using as template)
#
# Revision 1.5  2004/11/13 13:45:50  dansei
# support output only mode (don't save/writeback the replace result)
#
# Revision 1.4  2004/09/23 05:06:11  dansei
# - new option: --veryquiet
# - add to display modified-count at last.
#
# Revision 1.3  2004/09/22 08:25:26  dansei
# few
#

use strict;
use Getopt::Long;
use FileHandle;
use DirHandle;
use cmt::vcs;


my $recursive = 0;
my $backup_file = 0;
my $regex = 0;
my $binary = 0;
my $no_case = 0;
my $first_n = 0;

my $command;
my $cmd_exec;
my $cmd_args;
my $force = 0;
my $quiet = 0;
my $veryquiet = 0;
my $verbose = 0;
my $output_only = 0;

my $options = GetOptions(
                         'recursive|r' => \$recursive,
                         'backup|k' => \$backup_file,
                         'regular-expression|x' => \$regex,
                         'binary|b' => \$binary,
                         'output|o' => \$output_only,
                         'first|n=n' => \$first_n,
                         'ignore-case' => \$no_case,
                         'force' => \$force,
                         'quiet' => \$quiet,
                         'veryquiet|vq' => \$veryquiet,
                         'verbose|v' => \$verbose,
                         'help|?' => sub { &help },
                         'command=s' => \$command,
                         );

$backup_file = 0 if $output_only;
$veryquiet = 1 if $output_only;
$quiet = 1 if ($veryquiet);

help() if ($command and scalar(@ARGV) < 1);
help() if (!$command and scalar(@ARGV) < 3);

($cmd_exec, $cmd_args) = $command =~ m/^(.+?)(?:::(.*))?$/ if $command;

my ($fpat, $source, $target, @files) = @ARGV;
$fpat =~ s/\./\\./g;
$fpat =~ s/\*/.*/g;
$fpat =~ s/\?/./g;
$fpat = qr/$fpat/i;

print "normalized-file-pattern: $fpat\n" if $verbose;

my $n_source = length($source);
my $n_target = length($target);
$source = lc($source)  if $no_case;
$source = qr/$source/i if $regex and $no_case;
$source = qr/$source/  if $regex and not $no_case;
print "source pattern: $source\n" if $verbose;

@files = '.' if (scalar(@files) == 0);

if ($regex) {
	# process reg-ex escapes
} else {
	# process text escapes
}

my $total_dirty = 0;
for (@files) {
	# always enter into the specified directories
	$total_dirty += process_file($_, 1);
}

print "Total $total_dirty files are modified. \n" if not $veryquiet;


sub process_file {
	my ($file, $recur) = @_;

	if (-d $file) {
		print "d $file\n" if $verbose;
		my $count = 0;
		if ($recur) {
			my $dir = new DirHandle($file);
			my @list = $dir->read;
			for (@list) {
				# print "[".join(',',@list)."]\n" if $verbose;
				next if (m/^\.\.?$/);

				my $fpath = "$file/$_";
				if (-f $fpath) {
					#print "s $file\n" if $verbose;
					next if ($fpath !~ m/$fpat/);
				}

				$count += process_file($fpath, $recursive);
			}
		}
		return $count;
	}

	print "f $file\n" if not $quiet;
	my $fh = new FileHandle("<$file");
	return 0 if (! $fh);

	my @lines = <$fh>;
	$fh->close();

	if ($backup_file) {
		print "w $file.bak\n" if $verbose;
		my $fh_bak = new FileHandle("$file.bak");
		$fh_bak->write(@lines);
		$fh_bak->close();
	}

	my $dirty = 0;

	if ($command) {
		# repl.pl -c <command-line> <files-pattern> <source> <target>
		my $cmd_arg_parsed = eval("\"$cmd_args\"");
		print "x $cmd_exec $cmd_arg_parsed\n" if not $veryquiet;

		# run external program
		my @outs = `$cmd_exec $cmd_arg_parsed`;

		if (scalar(@lines) != scalar(@outs)) {
			$dirty = 1;
		} else {
			for (my $l = 0; $l < scalar(@lines); $l++) {
				if ($lines[$l] ne $outs[$l]) {
					$dirty = 1;
					last;
				}
			}
		}
		@lines = @outs if $dirty;
	} else {
		# default replace implementation
		for (my $l = 0; $l < scalar(@lines); $l++) {
			$_ = $lines[$l];
			if ($regex) {
			    my $res = '';
			    my $spos = 0;
			    while (m/$source/g) {
			        $res .= substr($_, $spos, $-[0] - $spos);
			        $res .= eval("\"$target\"");
			        $spos = $-[0] + length($&);
			    }
			    $res .= substr($_, $spos);
			        #print STDERR "[$_=>$res]\n";

			    if ($_ ne $res) {
			        $_ = $res;
					$dirty = 1;
				}
			} else {
				my $pos = $[;
				while (1) {
					if ($no_case) {
						$pos = index(lc($_), $source, $pos);
					} else {
						$pos = index($_, $source, $pos);
					}
					last if ($pos < $[);

					substr($_, $pos, $n_source) = $target;
					$pos += $n_target;
					$dirty = 1;
				}
			}
			$lines[$l] = $_;
		}
	}

	if ($output_only) {
	    for (@lines) {
	        print;
	    }
	} else {
	if ($dirty) {
		print "w $file\n" if not $veryquiet;
		#print "result\n";
		#print join("\n", @lines);
		$fh = new FileHandle(">$file");
		$fh->write(join("", @lines));
		$fh->close();
		return 1;
	}
    }

	return 0;
}


sub version() {
    my %id = parse_id('$Id: repl,v 1.11 2007-04-27 13:46:14 lenik Exp $');
    print "[REPL] Replace files by regular-expression\n";
    print "Written by Snima Denik   Version $id{rev}   Last updated at $id{date}\n";
}

sub help() {
    &version;
	print <<"EOM";

Syntax:
    $0
        --recursive (r)
        --backup (k)
        --regular-expression (x)
        --command=<external-command::arguments(\$var-names)> (c)
        --binary (b)
        --output (o)
        --first=<number> (n)
        --ignore-case (i)
        --force (f)
        --quiet (q)
        --veryquiet (vq)
        --verbose (v)
        --help (?)
        <file-pattern (reg-ex except .  ?  * instead of  \\.  .  .* )>
        <source-pattern (reg-ex or plain-text)>
        <target-pattern (reg-ex or plain-text)>
        [files or directories ... (default is current directory '.') ]

Variables:
    \$fpat          file pattern
    \$source        source pattern
    \$target        target pattern
    \$file          current file name
EOM
	exit 0;
}
