#!/usr/bin/perl

use strict;
use cmt::inet;
use cmt::serv;
use cmt::stream;
use cmt::util;
use cmt::vcs;
use cmt::win32;
use Data::Dumper;
use Getopt::Long;
# use IO::Socket;
use Term::ReadKey;

sub boot;
sub main;
sub info;
sub info2;
sub version;
sub help;

sub f_filter;
sub b_filter;
sub f_dump;
sub b_dump;
sub puts;

our $opt_verbtitle      = 'relay';
our $opt_verbtime       = 0;
our $opt_verbose        = 1;
our $opt_bind_address   = 'localhost';
our $opt_bind_port;
our $opt_target_host    = 'localhost';
our $opt_target_port    = 80;
our $opt_start_recver;
our $opt_start_sender;
our $opt_start_delay    = 1000;
our $opt_hexdump        = 0;
our $opt_rawdump;
our $opt_rawmask        = qr/[\x07]/;   # no-beep
our $opt_width          = 16;

my  $mios;
my  $mctx;

sub boot {
    GetOptions('quiet|q'    => sub { $opt_verbose-- },
               'verbose|v'  => sub { $opt_verbose++ },
               'version'    => sub { version; exit },
               'help|he'    => sub { help; exit },
               'bind-address|a=s',
               'bind-port|b=n',
               'target-host|h=s',
               'target-port|p=n',
               'start-recver|sr=s',
               'start-sender|ss=s',
               'start-delay|sd=n',
               'hexdump|x',
               'rawdump|r:s',
               );

    $opt_target_host = shift @ARGV if @ARGV;
    $opt_target_port = shift @ARGV if @ARGV;

    unless (defined $opt_bind_port) {
        $opt_bind_port = $opt_target_port;
        $opt_bind_port += 1000
            if ($opt_target_host eq $opt_bind_address);
    }

    info2 "bind-address:    $opt_bind_address";
    info2 "bind-port:       $opt_bind_port";
    info2 "target-host:     $opt_target_host";
    info2 "target-port:     $opt_target_port";
    info2 "start-recver:    $opt_start_recver";
    info2 "start-sender:    $opt_start_sender";
    info2 "start-delay:     $opt_start_delay";

    if (defined $opt_rawdump) {
        my $range   = '^' if $opt_rawdump =~ s/^!//;
        for (split(',', $opt_rawdump)) {
            my ($from, $to) = split('-', $_);
            $from   = '\x'.$from if defined $from;
            $to     = '\x'.$to   if defined $to;
            $range .= defined $to ? $from.'-'.$to : $from;
        }
        $opt_rawmask = eval "qr/[$range]/";
        info2 "rawmask:         $opt_rawdump";
    }

    main;
}

sub info {
    return if $opt_verbose < 1;
    my $text = shift;
    print cdatetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub info2 {
    return if $opt_verbose < 2;
    local $_ = $_[0];
    s/\a/^G/gs if $_[1];  # nobeep
    print cdatetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $_\n";
}

sub version {
    my %id = parse_id('$Id: relay,v 1.11 2007-11-08 10:52:37 lenik Exp $');
    print "[$opt_verbtitle] TCP Relay And Sniff \n";
    print "Written by Lenik,  Version 0.$id{rev},  Last updated at $id{date}\n";
}

sub help {
    version;
    print <<"EOM";

Syntax:
        $0 <options> [ <target-host> [<target-port>] ]

Options:
        --bind-address=<address>    (a, when specified, 1000 will be added to the bind-port)
        --bind-port=<port>          (b, default <target-port>)
        --target-host=<hostname>    (h, default localhost)
        --target-port=<port>        (p, default 80)
        --start-recver=<cmdline>    (sr)
        --start-sender=<cmdline>    (ss, cmdline is executed after the delay)
        --start-delay=<delay ms>    (sd, default 1000 ms)
        --hexdump                   (x, show hexdump column)
        --rawdump=[char-range]      (r, charcode out of range is shown as '.')
        --quiet                     (q)
        --verbose                   (v, repeat to get more info)
        --version
        --help

Deployment:
            +--------+      +----------------+      +--------+
            | source |----->| relayer (serv) |----->| target |
            +--------+      +----------------+      +--------+

    1, The source connects to the relayer and the relayer accepts the incoming
       request and creates a forward-stream (F-stm).
    2, F-stm::binded is triggered, where a connection from the relayer to the
       target is made (B-conn).  a backward-stream (B-stm) is also created.
       The B-conn & B-stm are encapsulated in field {Bk} of cmt::inet type.
   3a, The source sends data to the relayer and F-stm::gotdata is triggered,
       the data may be processed by F-filter, and then forwards to the target
       thru B-stm.
   3b, The target sends data to the relayer and B-stm::gotdata is triggered,
       the data may be processed by B-filter, and then forwards to the source
       thru F-stm.
   4a, Source disconnects from the relayer and F-stm::uninit is trigger, then
       the relayer disconnects from the target.
   4b, Target disconnects from the relayer and B-stm::uninit is trigger, then
       the relayer disconnects from the source.

EOM
}

exit boot;

sub main {
    my $pid_recver;
    my $pid_sender;
    if (defined $opt_start_recver) {
        $pid_recver = ntspawn($opt_start_recver);
        die "Can't spawn the recver process" unless defined $pid_recver;
        at_exit { ntkill $pid_recver };
    }
    if (defined $opt_start_sender) {
        fsleep($opt_start_delay / 1000.0);
        $pid_sender = ntspawn($opt_start_sender);
        at_exit { ntkill $pid_sender };
    }

    my $serv = new cmt::serv(sub {
        # Forward-Stream
        new cmt::stream(
            -binded => sub {
                # the source connected to the relayer (F-conn and this F-stm),
                # create a corresponding Bk object.
                my $s = shift;
                info "source ".$s->hinfo." connected";
                my $b_stm = relay_connect($s);
                $s->{b_stm} = $b_stm;
            },
            -unbinded => sub {
                # the source disconnected from the relayer,
                # so let's disconnect the target.
                my ($s, $fd) = @_;
                info2 "source ".$s->hinfo." disconnected";
                my $b_stm = $s->{b_stm};
                $b_stm->shutdown(2);
            },
            -gotdata => sub {
                # the source sent data to the relayer,
                # do f_filter and forward to the target.
                my ($s, $data) = @_;
                my $b_stm = $s->{b_stm};
                info2 "F-gotdata $s($b_stm): $data", 1;
                $data = f_filter($data);
                f_dump $data;
                if (defined $data) {
                    # return value??
                    return $b_stm->write($data);
                }
                1
            },
            -askdata => sub {
                # IGNORE
                # # Now can_write to the source
                # # let's check if any data available in the target.
                # my $s = shift;
                # my $b_stm = $s->{b_stm};
                # my $sendbuf = $b_stm->pull;
                # if ($sendbuf ne '') {
                #     $s->write($sendbuf);
                #     return 1;
                # }
                info2 "F-askdata @_";
                undef   # no sendbuf, let's skip -askdata next time.
            },
            -goterr => sub {
                # error between the source and the relayer
                # let's break both F-conn and B-conn
                my $s = shift;
                my $b_stm = $s->{b_stm};
                info2 "F-goterr $s($b_stm)";
                $b_stm->{ctx}->exit;
                $s->{ctx}->exit;
            },
        )},
        -port => $opt_bind_port,
        -name => 'relay');
    $serv->verbose($opt_verbose);

    $mios = $serv->create_ios()->merge;
    info "start relay-service at $opt_bind_address:$opt_bind_port";
    $mctx = $mios->create_context;
    while ($mctx->iterate) {
        my $k = ReadKey -1;
        if ($k) {
            info2 'pressed: $k('.ord($k).')';
            last if $k eq 'q';
        }
    }
    info2 Dumper($mctx->{STAT});
}

sub relay_connect {
    my $f_stm = shift;
    my $b_ios;
    my $b_stm = new cmt::stream(
        -binded => sub {
            # the connection is always made from the source to the target,
            # if the target would send-on-connect, this stream would gotdata, then.
            # so the relayer has nothing do with on-connect event.
            my ($s, $fd) = @_;
            info "target ".$s->hinfo." connected";
        },
        -unbinded => sub {
            # the target is disconnected from the relayer,
            # so let's disconnect the source.
            my ($s, $fd) = @_;
            info2 "target ".$s->hinfo." disconnected";
            info2 "Remove $b_ios, $fd";
            $mios->remove($b_ios);
            $mctx->remove($fd);
            $f_stm->shutdown(2);
        },
        -gotdata => sub {
            # the target sent data to the relayer,
            # do b_filter and forward to the source.
            my ($s, $data) = @_;
            info2 "B-gotdata $s: $data", 1;
            $data = b_filter($data);
            b_dump $data;
            if (defined $data) {
                # The return value??
                return $f_stm->write($data);
            }
            1
        },
        -askdata => sub {
            # now can_write to the target,
            # let's check if any data available in the source.
            my $s = shift;
            info2 "B-askdata $s";
            my $sendbuf = $f_stm->pull;
            info2 "B-askdata resp: $sendbuf", 1;
            if ($sendbuf ne '') {
                $s->write($sendbuf);
                return 1;
            }
            undef   # no sendbuf, let's skip -askdata next time.
        },
        -goterr => sub {
            # error between the relayer and the target
            # let's break both B-conn and F-conn
            my $s = shift;
            info2 "B-goterr $s";
            $s->{ctx}->exit;
            $f_stm->{ctx}->exit;
        },
    );
    $b_ios = tcp_connect($opt_target_host, $opt_target_port, $b_stm,
                            -cont => 1);
    my $b_fd = $b_ios->{HANDLE};
    info2 "Merge  $b_ios, $b_fd";
    $mios->merge($b_ios);
    $mctx->add($b_fd);
    return $b_stm;
}

sub f_filter {
    my $data = shift;
    return $data;
}

sub b_filter {
    my $data = shift;
    return $data;
}

sub f_dump  { puts 'F', shift }
sub b_dump  { puts 'B', shift }

my %FROMBUF;
sub puts {
    my $from    = shift;
    local $_    = shift;
    my $cont    = $FROMBUF{$from};
    my $indent  = length($from) + 2;

    if ($opt_hexdump) {
        my $TOHEX = 'H'.($opt_width * 2);
        my $buf;
        while (length $_) {
            $buf .= "\n" if defined $buf;
            my $part = substr($_, 0, $opt_width);
                  $_ = substr($_, $opt_width);
            (my $txt = $part) =~ s/[\x00-\x1f]/./g;
            my $code;
            $code = unpack $TOHEX, $part;
            while (length $code) {
                $buf .= substr($code, 0, 2) . ' ';
                $code = substr($code, 2);
            }
            $buf .= '   'x($opt_width - length $part);
            $buf .= "| $txt";
        }
        $_ = substr(indent($indent, $buf), $indent);
        print "$from> $_\n";
    } else {
        s/$opt_rawmask/./sg if defined $opt_rawmask;
        $_ = substr(indent($indent, $_), $indent);
        print "$from> $_\n";
    }
}
