#!/usr/bin/perl

use strict;
use cmt::vcs;
use DirHandle;
use Getopt::Long;
use Data::Dumper;

my %opt_ext = (
        'c' => 'c',
        'cxx' => 'c',
        'cpp' => 'c',
        'h' => 'c',
        'hxx' => 'c',
        'hpp' => 'c',
        'java' => 'c',
        'js' => 'c',

        'sh' => 'unix',
        'bat' => 'text',

        'p' => 'unix',
        'pl' => 'unix',
        'python' => 'unix',
        'tcl' => 'unix',

        'bas' => 'vb',
        'frm' => 'vb',
        'cls' => 'vb',

        'txt' => 'text',

        'htm' => 'text',
        'html' => 'text',
        'css' => 'text',

        'xml' => 'xml',
        'xsl' => 'xml',
        'xslt' => 'xml',
        'xsd' => 'xml',
        'dtd' => 'xml',
        'xq' => 'xml',

        'php' => 'text',
        'asp' => 'text',
        'jsp' => 'text',
       );

my $opt_quiet = 0;
my $opt_veryquiet = 0;
my $opt_verbose = 0;
my $opt_force = 0;
my $opt_recursive = 0;
my @opt_matches;                # only matches if defined.
my $opt_summary = 1;

my %summary = ();               # summary of all.
my %summary_x = ();             # summary by different extensions.


sub main {
    my $options = GetOptions(
            'extension|e=s' =>
                    sub {
                        my ($key, $val) = split('=', $_[1]);
                        $val ||= "text";
                        $opt_ext{$key} = $val;
                    },
            'exclude|x=s' =>
                    sub {
                        my $key = $_[1];
                        delete $opt_ext{$key};
                    },
            'recursive' => \$opt_recursive,
            'summary!' => \$opt_summary,
            'force' => \$opt_force,
            'quiet' => \$opt_quiet,
            'veryquiet|vq' => \$opt_veryquiet,
            'verbose|v' => \$opt_verbose,
            'help|h' => sub { &help; },
            );
    $opt_quiet = 1 if $opt_veryquiet;

    my @list;
    my $k;

    for (@ARGV) {
        if (m/\?/ or m/\*/) {
            s/\./\\./g;
            s/\?/./g;
            s/\*/.*/g;
            push @opt_matches, $_;
        } else {
            push @list, $_;
        }
    }

    if (scalar(@list) == 0) {
        if ($opt_recursive or @opt_matches) {
            # all files under current directory if patterns specified
            @list = ('.');
        } else {
            # otherwise, use stdin if no arguments
            @list = ('con');
        }
    }

    while (my $fn = shift @list) {
        my %c = process($fn);
        for $k (keys %c) {
            $summary{$k} += 1 * $c{$k};
        }
    }

    if ($opt_summary) {
        for $k (keys %summary_x) {
            my $c_x = $summary_x{$k};
            printf "%10d <.$k>\n", $c_x->{'body'} if not $opt_quiet;
        }
        printf "%10d <<total>>\n", $summary{'body'} if not $opt_veryquiet;
    }
}


sub process {
    my ($fn) = @_;
    my %counts = ();
    my ($fext, $fmodel);
    if (-d $fn) {
        print "[DIR] $fn\n" if $opt_verbose;

        my $dh = new DirHandle($fn);
        my @files = $dh->read();
        $dh->close();
        for (@files) {
            my %c = ();

            if (-d "$fn/$_") {
                # recursive into sub-directories
                next if (m/^\.{1,2}$/);
                next if (! $opt_recursive);
                %c = process("$fn/$_");
            } else {
                # file-item in a directory

                # only matches if @opt_matches is defined.
                if (@opt_matches) {
                    my $matches = 0;
                    for my $pat (@opt_matches) {
                        if (m/^$pat$/i) {
                            $matches = 1;
                            last;
                        }
                    }
                    next if not $matches;
                }

                ($fext) = m/\.([^.\/]+)$/;
                if (defined $opt_ext{$fext}) {
                    %c = process("$fn/$_");
                }
            }
            for my $k (keys %c) {
                $counts{$k} += 1 * $c{$k};
            }
        }
        $fn = "$fn/";
    } else {
        print "[FILE] $fn\n" if $opt_verbose;

        ($fext) = $fn =~ m/\.([^.\/]+)$/;
        my $fext_as = $fext;
            $fext_as ||= 'txt';
        $fmodel = $opt_ext{$fext_as};
            # || die "Unknown extension: $fext";
            $fmodel ||= 'text';

        my $count_func = eval "\\&count_$fmodel";
        %counts = &$count_func($fn);
        for my $k (keys %counts) {
            $summary_x{$fext}->{$k} += 1 * $counts{$k};
        }
    }

    my $disp = not $opt_quiet;
    $disp = 0 if ($counts{'body'} == 0 and not $opt_verbose);
    printf "%10d $fn\n", $counts{'body'} if $disp;
    return %counts;
}


sub count_text {
    my ($filename) = @_;
    my $lines = 0;
    my $words = 0;
    open FH, $filename or die "can't open file $filename";
    while (<FH>) {
        $words++ while (m/\w+/g);
        $lines++;
    }
    close FH;
    return (
            'body' => $lines,
            'words' => $words,
            );
}


sub count_c {
    my ($filename) = @_;
    my $lines = 0;
    my $words = 0;
    my $cmtlines = 0;
    open FH, $filename or die "can't open file $filename";
    while (<FH>) {
        $words++ while (m/\w+/g);
        $lines++;
        $cmtlines++ if (m/^\s*(\/\/.*)?$/);
    }
    close FH;
    return (
            'body' => $lines,
            'words' => $words,
            'comments' => $cmtlines,
            );
}


sub count_vb {
    my ($filename) = @_;
    my $hdrlevel = -100;
    my ($lines, $words) = (0, 0);
    my ($hdrlines, $cmtlines) = (0, 0);
    my $attr = 1;

    open FH, $filename or die "can't open file $filename";
    while (<FH>) {
        $hdrlines++;
        if (m/^\s*VERSION\b/i)  { $hdrlevel = 0; next; }
        if (m/^\s*OBJECT\b/i)   { next; }
        if (m/^\s*BEGIN\s+=/i)  { next; }
        if (m/^\s*BEGIN\b/i)    { $hdrlevel++; }
        if (m/^\s*END\b/i)      { $hdrlevel--; }
        if ($hdrlevel == 0)     { last; }
    }
    while (<FH>) {
        if ($attr) {
            if (m/^\s*ATTRIBUTE\b/i) {
                $hdrlines++;
                next;
            }
        }
        $attr = 0;

        $lines++;
        $words++ while (m/\w+/g);
        $cmtlines++ if (m/^\s*(\'.*)?$/);
    }

    close FH;
    return (
            'body' => $lines,
            'words' => $words,
            'header' => $hdrlines,
            'comments' => $cmtlines,
            );
}


sub count_unix {
    my ($filename) = @_;
    my $lines = 0;
    my $words = 0;
    my $cmtlines = 0;
    open FH, $filename or die "can't open file $filename";
    while (<FH>) {
        $words++ while (m/\w+/g);
        $lines++;
        $cmtlines++ if (m/^\s*(#.*)?$/);
    }
    close FH;
    return (
            'body' => $lines,
            'words' => $words,
            'comments' => $cmtlines,
            );
}


sub count_xml {
    return count_text(@_);
}


sub help {
    my %id = parse_id('$Id: wcc,v 1.8 2005-12-20 02:39:25 dansei Exp $');
    print <<"EOM";
Words Count for Source Code   Version $id{'rev'}   Date $id{'date'}
Syntax:
    wcc
        --help (h)
        --extension=<ext-name>[=<type-mapping>] (e)
        --exclude=<ext-name to be excluded> (x)
        --recursive (r)
        --summary --nosummary
        --force (f)
        --quiet (q)
        --veryquiet (vq)
        --verbose (v)
        --help (h)
        files...
EOM
    exit;
}

&main;
