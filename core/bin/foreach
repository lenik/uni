#!/usr/bin/perl

use strict;
use DirHandle;
use Getopt::Long;
use cmt::vcs;
use cmt::path;


    our $opt_recursive = 0;
    our $opt_quiet = 0;
    our $opt_verbose = 0;
    our $opt_directories_only = 0;
    our $opt_files_only = 0;
    our $opt_continue_with_errors = 0;
    our $opt_script = undef;            # <STDIN> default
    our @opt_files;


    # COMMAND-LINE PARSING
    GetOptions(
        'recursive',
        'quiet',
        'directories-only',
        'files-only',
        'continue-with-errors',
        'script=s',
        'version' => sub { &version; exit },
        'help' => sub { &help, exit },
        );

    $opt_verbose = not $opt_quiet;

    if ($opt_directories_only && $opt_files_only) {
        die 'Illegal arguments: Both directories-only and files-only are specified. ';
    }

    my @lines;
    if ($opt_script) {
        open(SCRIPT, "<$opt_script")
            or die "Can't read from file $opt_script";
        @lines = <SCRIPT>;
        close SCRIPT;
    } else {
        @lines = <STDIN>;
    }
    $opt_script = join('', @lines);

    my $compile = eval(<<"EOM");
        sub process {
            my \$path = \$_[0];
            my (\$dir, \$base) = path_split(\$path);
            my (\$file, \$ext) = path_splitext(\$base);
            $opt_script
        }
EOM
    die "Can't evaluate: $@" if $@;

    # find -- if any
    my $el = -1;
    while (++$el < scalar(@ARGV)) {
        last if ($ARGV[$el] eq '--');
    }
    @opt_files = splice(@ARGV, 0, $el - 1);
    shift @ARGV;    # remove --

    # default ./ if none is specified.
    @opt_files = ('.') unless @opt_files;


    # PROCESSING
    my $count = process_files('', @opt_files);

    # RESULTS
    if (not $opt_quiet) {
        print <<"EOM";
Total $count files/directories processed.
EOM
    }



sub process_dir {
    my $dir = shift || $_;
    # print "[SCAN] $dir\n" if $opt_verbose;

    my $count = 0;
    if (not $opt_files_only) {
        $count += process_file($dir);
    }

    my $dh = new DirHandle($dir);
    if (not $dh) {
        if ($opt_continue_with_errors) {
            return $count;
        }
        die "Can't access directory $dir";
    }

    my @files = $dh->read;
    for (my $i = scalar(@files) - 1; $i >= 0; $i--) {
        local $_ = $files[$i];
        my $k = 0;
        $k = 1 if m/^\.+$/;
        $_ = "$dir/$_";
        $k = 1 if not $opt_recursive and -d;
        $k = 1 if not -d and not -f;
        splice(@files, $i, 1) if $k;
    }

    return process_files($dir, @files);
}


sub process_files {
    my $base = shift;
    my $count = 0;
    for (@_) {
        my $path = "$_";
        $path = "$base/$_" if $base;
        $count += &process_dir($path) if -d $path;
        $count += &process_file($path) if -f $path;
    }
    return $count;
}


sub process_file {
    my $path = shift || $_;
    print " [DIR] $path\n" if -d $path and not $opt_quiet;
    print "[FILE] $path\n" if -f $path and not $opt_quiet;

    my $count = 0;
    $count++ if process($path);

    return $count;
}


sub version {
    my %id = parse_id('$Id: foreach,v 1.2 2005-07-05 07:04:16 dansei Exp $');
    print <<"EOM";
[foreach] files processor framework   version $id{rev}
author: lenik,  last update: $id{date}
EOM
}


sub help {
    &version;
    print <<"EOM";

syntax:
    foreach
        --recursive (r)
        --quiet (q)
        --directories-only (d)
        --files-only (f)
        --continue-with-errors (c)
        --script=<perl-script-file> (s, default read from stdin)
        --version (v)
        --help (h)
        [files/directories ...]     (default '.')

variables:
    path dir base file ext opt_*

EOM
}
