#!/usr/bin/perl

use strict;
use cmt::path;
use cmt::util;
use cmt::vcs;
use Getopt::Long;

sub boot;
sub main;
sub info;
sub info2;
sub version;
sub help;

sub scan_dir;
sub process_item;
sub ls;
sub search;
sub ren;
sub safechar;
sub sortby_name;
sub sortby_size;

our $opt_verbtitle          = 'foreach';
our $opt_verbtime           = 0;
our $opt_verbose            = 1;
our $opt_recursive          = 0;
our $opt_directories_only   = 0;
our $opt_cont_errors        = 0;
our $opt_eval               = undef;    # <STDIN> default
our $opt_first_is_script    = 0;
our $opt_test_only          = 0;
our $opt_sort               = undef;    # 'name' default
our $opt_reversed           = 0;
our @opt_lists              = ();

my @files;
my @lists;
my @L;

sub boot {
    for my $i (0..$#ARGV) {
        if ($ARGV[$i] eq '--') {
            @files = splice(@ARGV, $i + 1);
            pop @ARGV;
        }
    }
    GetOptions('quiet|q'    => sub { $opt_verbose-- },
               'verbose|v'  => sub { $opt_verbose++ },
               'version'    => sub { version; exit },
               'help|h'     => sub { help; exit },
               'recursive|r',
               'directories-only',
               'files-only',
               'cont-errors',
               'eval|e=s',
               'first-is-script|s',
               'test-only',
               'sort|o=s',
               'reversed',
               'list|l=s'   => \@opt_lists,
               );
    if (@ARGV) {
        push @files, @ARGV;
        @ARGV = ();
    }

    if ($opt_sort) {
        my $func = 'sortby_'.$opt_sort;
        die("Invalid sort type: $opt_sort") unless main->can($func);
        $opt_sort = \&$func;
    }

    if ($opt_first_is_script) {
        my $f = shift @files;
        die "script file isn't specified" unless defined $f;
        die "script file isn't existed" unless -e $f;
        my $script = readfile($f);
        $opt_eval .= $script;
    }

    unless (defined $opt_eval) {
        print STDERR "Enter the script (use -n option to suppress): \n";
        while (<STDIN>) {
            $opt_eval .= $_;
        }
    }

    eval(<<"EOM");
        sub process {
            my \$path = \$_[0];
            local (\$_) = \$path;
            my (\$dir, \$base) = path_split(\$path);
            my (\$old, \$new) = (\$base, \$base);
            my (\$file, \$ext) = path_splitext(\$base);
            my (\$path2, \$dir2, \$base2, \$file2, \$ext2) =
               (\$path,  \$dir,  \$base,  \$file,  \$ext );
            my (\$a, \$b, \$c, \$d, \$e, \$f, \$g, \$h, \$i, \$j,
                \$k, \$l, \$m, \$n, \$o, \$p, \$q, \$r, \$s, \$t,
                \$u, \$v, \$w, \$x, \$y, \$z);
            my (\$L, \$M, \$N, \$O, \$P, \$Q, \$R, \$S, \$T, \$U) = \@L;
            sub r   ; *r = sub
                    { print "ren(\$old, \$new)\n" };
            1;
            $opt_eval
        }
EOM
    die "Can't evaluate: $@" if $@;

    main;
}

sub info {
    return if $opt_verbose < 1;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub info2 {
    return if $opt_verbose < 2;
    my $text = shift;
    print datetime.' ' if $opt_verbtime;
    print "[$opt_verbtitle] $text\n";
}

sub version {
    my %id = parse_id('$Id: foreach,v 1.13 2007-07-02 10:30:09 lenik Exp $');
    print "[$opt_verbtitle] files processor framework \n";
    print "Written by Lenik,  Version $id{rev},  Last updated at $id{date}\n";
}

sub help {
    version;
    print <<"EOM";

Syntax:
    foreach
        --recursive (r)
        --directories-only (d)
        --cont-errors (c)
        --eval=<script> (e, default read from stdin)
        --first-is-script (s, first of files is the script file)
        --noscript
        --test-only
        --sort=<type> (o, can be name(default), size, etc)
        --reversed (reverse sort)
        --quiet (q)
        --verbose (v)
        --version
        --help (h)
        [files/directories ...]     (default '.')

variables:
    path dir base file ext opt_*

function:
    ren(old, new)
EOM
}

exit boot;

sub scan_dir {
    my $dir = shift || $_;
    # print "[SCAN] $dir\n" if $opt_verbose;

    my @fs = ls $dir;
    for (my $i = scalar(@fs) - 1; $i >= 0; $i--) {
        local $_ = $files[$i];
        my $k = 0;
        $k = 1 if m/^\.+$/;
        $_ = "$dir/$_";
        $k = 1 if $opt_directories_only and -f;
        splice(@fs, $i, 1) if $k;
    }

    my $count = 0;
    for (@fs) {
        my $path = "$dir/$_";
        $count += process_item($path);
        $count += scan_dir($path) if $opt_recursive and -d $path;
    }
    return $count;
}

sub process_item {
    my $path = shift || $_;
    info2 "$path/" if -d $path;
    info2 "$path" if -f $path;

    my $count = 0;
    for (@opt_lists) {
        return if ($path eq $_) ;
    }
    @L = ();
    for (@lists) {
        my $l = <$_>;
        $l =~ s/\s+$//;
        push @L, $l;
    }

    $count++ if process($path);

    return $count;
}

sub ls {
    my $path = shift;
    my $dh = new DirHandle($path);
    if (not $dh) {
        if ($opt_cont_errors) {
            return ();
        }
        die "Can't access directory $path";
    }
    my @fs = $dh->read;
    return @fs;
}

sub search {
    my ($list, $item) = @_;
    for (@$list) {
        return 1 if ($item eq $_);
    }
    return 0;
}

my $padx = ' 'x40;
sub ren {
    my ($old, $new) = @_;
    return if $old eq $new;
    die "Non-Existing source: $old" unless -e $old;
    die "Existing target: $new" if -e $new;
    if ($opt_verbose > 0) {
        if (length($old) < 40) {
            print "rename ".substr("$old$padx", 0, 40)."--> $new\n";
        } else {
            print "rename $old\n   --> $new\n";
        }
    }
    rename($old, $new) unless $opt_test_only;
}

sub safechar {
    my $s = shift;
    $s =~ s/[:\/\\?*]/_/g;
    return $s;
}

sub sortby_name {
    return $a cmp $b;
}

sub sortby_size {
    return -s $a <=> -s $b;
}

sub main {
    for (@opt_lists) {
        open my $fh, "<$_" or die "Can't open list-file: $_";
        push @lists, $fh;
    }

    # default ./* if none is specified.
    if (! @files) {
        @files = grep { !(/^\.+$/ or $opt_directories_only and -f) } (<.*>, <*>);
    }

    # PROCESSING
    my $count = 0;
    @files = sort $opt_sort @files if $opt_sort;
    @files = reverse @files if $opt_reversed;
    for (@files) {
        $count += process_item($_);
        $count += scan_dir($_) if $opt_recursive and -d;
    }

    close $_ for @opt_lists;
    info "Total $count files/directories processed. ";
}
